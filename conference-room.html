<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Conference Room | The AI Lobby</title>
  <link rel="stylesheet" href="css/styles.css">
  <style>
    /* iOS Input Focus Fix - Prevents white screen when keyboard opens */
    html, body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100%;
      min-height: -webkit-fill-available;
    }

    html {
      height: -webkit-fill-available;
    }

    /* Prevent iOS zoom on input focus (16px min font prevents zoom) */
    input, textarea, select {
      font-size: 16px !important;
    }

    /* Conference Room Styles */
    .conference-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 1.5rem;
    }

    .conference-header {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .conference-header h1 {
      color: var(--stability-green);
      margin-bottom: 0.5rem;
    }

    .conference-header p {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    /* Main Layout */
    .conference-layout {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 1.5rem;
    }

    @media (max-width: 1000px) {
      .conference-layout {
        grid-template-columns: 1fr;
      }
    }

    /* Main Content Area */
    .main-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* Visual Scene */
    .conference-scene {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid var(--border-subtle);
    }

    .scene-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('images/conference room.png');
      background-size: cover;
      background-position: center;
    }

    .scene-empty-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--text-muted);
      font-size: 1.1rem;
      text-align: center;
      opacity: 0.7;
      display: none;
    }

    /* ========================================
       MEETING MODE - Zoom-like Layout
       ======================================== */

    .meeting-view {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      flex-direction: column;
      background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 100%);
      z-index: 10;
    }

    .conference-scene.meeting-mode .scene-background,
    .conference-scene.meeting-mode .character-slot,
    .conference-scene.meeting-mode .scene-empty-text {
      display: none !important;
    }

    .conference-scene.meeting-mode .meeting-view {
      display: flex;
    }

    /* Facilitator - Large center display */
    .facilitator-display {
      flex: 2;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
    }

    .facilitator-card {
      position: relative;
      width: 400px;
      height: 300px;
      border-radius: 12px;
      overflow: hidden;
      border: 3px solid var(--stability-green);
      box-shadow: 0 0 30px rgba(46, 204, 113, 0.3);
      background: linear-gradient(135deg, #2c3e50 0%, #1a1a2e 100%);
    }

    .facilitator-card.speaking {
      box-shadow: 0 0 40px rgba(46, 204, 113, 0.6);
      animation: facilitator-pulse 1.5s infinite;
    }

    @keyframes facilitator-pulse {
      0%, 100% { box-shadow: 0 0 30px rgba(46, 204, 113, 0.4); }
      50% { box-shadow: 0 0 50px rgba(46, 204, 113, 0.7); }
    }

    .facilitator-card img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .facilitator-badge {
      position: absolute;
      top: 10px;
      left: 10px;
      background: var(--stability-green);
      color: white;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .facilitator-name {
      display: none;  /* Hidden until JS shows it */
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 0.75rem;
      background: linear-gradient(transparent, rgba(0,0,0,0.9));
      color: var(--stability-green);
      font-weight: bold;
      font-size: 1.1rem;
      text-align: center;
    }

    .facilitator-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-muted);
    }

    .facilitator-empty .icon {
      font-size: 3rem;
      margin-bottom: 0.5rem;
      opacity: 0.5;
    }

    /* Human Facilitator Controls */
    .facilitator-human-controls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.75rem;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      margin: 0.5rem auto;
      max-width: 400px;
    }
    .facilitator-message-row, .facilitator-image-row {
      display: flex;
      gap: 0.5rem;
    }
    .facilitator-message-row input { flex: 1; }
    .facilitator-broadcast {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(46, 204, 113, 0.95);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      max-width: 80%;
      text-align: center;
      animation: fadeIn 0.3s ease;
      z-index: 10;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    .facilitator-shared-image {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--panel-bg);
      padding: 1rem;
      border-radius: 12px;
      z-index: 100;
      border: 2px solid var(--stability-green);
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
    }
    .facilitator-shared-image img {
      max-width: 600px;
      max-height: 400px;
      border-radius: 8px;
    }
    .facilitator-shared-image button {
      margin-top: 0.75rem;
      width: 100%;
    }

    /* Attendees Grid - Smaller squares */
    .attendees-grid {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 0.75rem;
      padding: 1rem;
      max-height: 140px;
      overflow-x: auto;
    }

    .meeting-attendee-card {
      width: 90px;
      height: 90px;
      border-radius: 8px;
      overflow: hidden;
      border: 2px solid var(--border-subtle);
      background: rgba(0,0,0,0.5);
      position: relative;
      transition: all 0.3s ease;
      flex-shrink: 0;
    }

    .meeting-attendee-card.speaking {
      border-color: var(--lobby-highlight);
      box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
      animation: attendee-speak 1.5s infinite;
    }

    @keyframes attendee-speak {
      0%, 100% { box-shadow: 0 0 15px rgba(233, 69, 96, 0.5); }
      50% { box-shadow: 0 0 25px rgba(233, 69, 96, 0.7); }
    }

    .meeting-attendee-card img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .meeting-attendee-card .attendee-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 0.2rem;
      background: rgba(0,0,0,0.85);
      font-size: 0.65rem;
      text-align: center;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .attendees-empty {
      color: var(--text-muted);
      font-size: 0.85rem;
      text-align: center;
      padding: 1rem;
    }

    /* Raised Hand Styles */
    .meeting-attendee-card.hand-raised {
      border-color: #f1c40f;
      box-shadow: 0 0 15px rgba(241, 196, 15, 0.6);
      animation: hand-pulse 1.5s infinite;
    }

    @keyframes hand-pulse {
      0%, 100% { box-shadow: 0 0 15px rgba(241, 196, 15, 0.5); }
      50% { box-shadow: 0 0 25px rgba(241, 196, 15, 0.8); }
    }

    .raised-hand-icon {
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 1rem;
      animation: wave 0.5s infinite;
      z-index: 5;
    }

    @keyframes wave {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(15deg); }
    }

    .raise-hand-btn {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.55rem;
      padding: 0.15rem 0.35rem;
      background: rgba(0,0,0,0.8);
      border: 1px solid #f1c40f;
      color: #f1c40f;
      border-radius: 4px;
      cursor: pointer;
      z-index: 5;
      transition: all 0.2s ease;
    }

    .raise-hand-btn:hover {
      background: rgba(241, 196, 15, 0.2);
    }

    /* Attendee Question Input Area */
    .attendee-question-area {
      background: linear-gradient(135deg, rgba(241, 196, 15, 0.15), rgba(241, 196, 15, 0.05));
      border: 2px solid #f1c40f;
      border-radius: 8px;
      padding: 0.75rem;
      margin-top: 0.75rem;
      animation: pulse-glow 2s ease-in-out infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 10px rgba(241, 196, 15, 0.3); }
      50% { box-shadow: 0 0 20px rgba(241, 196, 15, 0.5); }
    }

    .question-label {
      color: #f1c40f;
      font-weight: 600;
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
    }

    .question-input-row {
      display: flex;
      gap: 0.5rem;
    }

    .question-input-row .chat-input {
      flex: 1;
    }

    /* Meeting Transcript */
    .meeting-transcript {
      background: rgba(10, 25, 47, 0.95);
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      margin-top: 1rem;
      max-height: 300px;
      display: flex;
      flex-direction: column;
    }

    .transcript-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid var(--border-subtle);
      background: rgba(0,0,0,0.3);
    }

    .transcript-header h3 {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-primary);
    }

    .presentation-status {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .status-indicator.active {
      background: var(--stability-green);
      animation: pulse 1.5s ease-in-out infinite;
    }

    .status-indicator.paused {
      background: #f1c40f;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .transcript-log {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
      max-height: 250px;
    }

    .meeting-message {
      display: flex;
      gap: 0.5rem;
      padding: 0.4rem;
      margin-bottom: 0.4rem;
      border-radius: 6px;
      background: rgba(0,0,0,0.2);
    }

    .meeting-message.facilitator-msg {
      background: rgba(46, 204, 113, 0.1);
      border-left: 3px solid var(--stability-green);
    }

    .meeting-message.attendee-msg {
      background: rgba(52, 152, 219, 0.1);
      border-left: 3px solid #3498db;
    }

    .meeting-message.question-msg {
      background: rgba(241, 196, 15, 0.1);
      border-left: 3px solid #f1c40f;
    }

    .meeting-message .speaker-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      object-fit: cover;
    }

    .meeting-message .message-content {
      flex: 1;
    }

    .meeting-message .speaker-name {
      font-weight: 600;
      font-size: 0.75rem;
      color: var(--text-primary);
      margin-bottom: 0.15rem;
    }

    .meeting-message .message-text {
      font-size: 0.8rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .mode-btn {
      flex: 1;
      padding: 0.5rem;
      background: rgba(0,0,0,0.3);
      border: 2px solid var(--border-subtle);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.2s;
    }

    .mode-btn:hover {
      border-color: var(--stability-green);
      color: var(--text-primary);
    }

    .mode-btn.active {
      background: rgba(46, 204, 113, 0.2);
      border-color: var(--stability-green);
      color: var(--stability-green);
    }

    /* Meeting Controls Panel */
    .meeting-setup {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .meeting-setup label {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
      display: block;
    }

    .meeting-topic-display {
      background: rgba(52, 152, 219, 0.2);
      padding: 0.75rem;
      border-radius: 8px;
      margin-bottom: 0.75rem;
      border-left: 3px solid #3498db;
    }

    .meeting-topic-display .label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .meeting-topic-display .topic {
      font-weight: bold;
      color: #3498db;
      margin-top: 0.25rem;
    }

    /* Attendee Selection */
    .attendee-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.5rem;
    }

    .attendee-chip {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.25rem 0.5rem;
      background: rgba(46, 204, 113, 0.2);
      border: 1px solid var(--stability-green);
      border-radius: 15px;
      font-size: 0.7rem;
      color: var(--stability-green);
    }

    .attendee-chip .remove {
      cursor: pointer;
      opacity: 0.7;
    }

    .attendee-chip .remove:hover {
      opacity: 1;
    }

    .add-attendee-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .add-attendee-row select {
      flex: 1;
    }

    .add-attendee-btn {
      padding: 0.4rem 0.75rem;
      background: var(--stability-green);
      border: none;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .add-attendee-btn:hover {
      background: #27ae60;
    }

    /* Character Position Slots - around the conference table */
    .character-slot {
      position: absolute;
      width: 65px;
      height: 65px;
      border-radius: 50%;
      border: 3px solid var(--stability-green);
      background: rgba(0, 0, 0, 0.5);
      overflow: hidden;
      transition: all 0.3s ease;
      cursor: pointer;
      display: none;
    }

    .character-slot.occupied {
      display: block;
      animation: popIn 0.4s ease;
    }

    .character-slot.candidate {
      border-color: var(--chaos-purple);
      box-shadow: 0 0 15px rgba(155, 89, 182, 0.4);
    }

    @keyframes popIn {
      0% { transform: scale(0); opacity: 0; }
      70% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    .character-slot:hover {
      transform: scale(1.15);
      box-shadow: 0 0 20px rgba(46, 204, 113, 0.5);
    }

    .character-slot.candidate:hover {
      box-shadow: 0 0 20px rgba(155, 89, 182, 0.6);
    }

    .character-slot img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-slot .char-name {
      position: absolute;
      bottom: -22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.65rem;
      white-space: nowrap;
      color: var(--text-primary);
    }

    .character-slot.candidate .char-name {
      background: rgba(155, 89, 182, 0.85);
    }

    /* Position slots around conference table - adjusted for the image */
    .character-slot[data-position="left-1"] { bottom: 42%; left: 8%; }
    .character-slot[data-position="left-2"] { bottom: 28%; left: 12%; }
    .character-slot[data-position="head"] { bottom: 45%; left: 45%; }
    .character-slot[data-position="right-1"] { bottom: 42%; right: 8%; }
    .character-slot[data-position="right-2"] { bottom: 28%; right: 12%; }
    .character-slot[data-position="front-1"] { bottom: 12%; left: 30%; }
    .character-slot[data-position="front-2"] { bottom: 12%; right: 30%; }

    /* Chat Section - Dual Panel Layout */
    .interview-chat-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    @media (max-width: 900px) {
      .interview-chat-container {
        grid-template-columns: 1fr;
      }
    }

    .chat-panel {
      background: rgba(15, 52, 96, 0.5);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      max-height: 400px;
    }

    .chat-panel.employee-panel {
      border-color: rgba(46, 204, 113, 0.4);
    }

    .chat-panel.candidate-panel {
      border-color: rgba(155, 89, 182, 0.4);
    }

    /* Legacy single section (keeping for backwards compat) */
    .chat-section {
      background: rgba(15, 52, 96, 0.5);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      max-height: 400px;
    }

    .chat-header {
      padding: 0.75rem 1rem;
      background: rgba(46, 204, 113, 0.15);
      border-bottom: 1px solid var(--border-subtle);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chat-header h2 {
      margin: 0;
      font-size: 1rem;
      color: var(--stability-green);
    }

    .chat-log {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      min-height: 200px;
    }

    .chat-message {
      margin-bottom: 0.75rem;
      display: flex;
      gap: 0.5rem;
      align-items: flex-start;
    }

    .chat-message .avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
      border: 2px solid var(--border-subtle);
    }

    .chat-message .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .chat-message .avatar.candidate-avatar {
      border-color: var(--chaos-purple);
    }

    .chat-message .message-body {
      flex: 1;
      min-width: 0;
    }

    .chat-message .sender-name {
      font-size: 0.75rem;
      font-weight: 600;
      margin-bottom: 0.15rem;
    }

    .chat-message .sender-name.employee { color: var(--stability-green); }
    .chat-message .sender-name.candidate { color: var(--chaos-purple); }
    .chat-message .sender-name.system { color: var(--text-muted); }

    .chat-message .message-text {
      font-size: 0.85rem;
      line-height: 1.4;
      color: var(--text-primary);
    }

    .chat-message.system-msg {
      justify-content: center;
    }

    .chat-message.system-msg .message-text {
      background: rgba(155, 135, 175, 0.15);
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--text-muted);
      font-style: italic;
    }

    .chat-input-area {
      padding: 0.75rem;
      border-top: 1px solid var(--border-subtle);
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .avatar-picker {
      position: relative;
    }

    .avatar-picker-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid var(--stability-green);
      overflow: hidden;
      cursor: pointer;
      background: rgba(0,0,0,0.3);
      padding: 0;
    }

    .avatar-picker-btn img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .avatar-picker-dropdown {
      position: absolute;
      bottom: 100%;
      left: 0;
      background: rgba(15, 52, 96, 0.98);
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      padding: 0.5rem;
      display: none;
      flex-wrap: wrap;
      gap: 0.5rem;
      max-width: 200px;
      margin-bottom: 0.5rem;
      z-index: 100;
    }

    .avatar-picker-dropdown.show {
      display: flex;
    }

    .avatar-option {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid var(--border-subtle);
      overflow: hidden;
      cursor: pointer;
      padding: 0;
      background: none;
    }

    .avatar-option:hover {
      border-color: var(--stability-green);
    }

    .avatar-option img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .chat-input {
      flex: 1;
      padding: 0.5rem 0.75rem;
      background: rgba(10, 25, 47, 0.8);
      border: 2px solid var(--border-subtle);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 16px; /* iOS requires 16px minimum to prevent zoom on focus */
      -webkit-appearance: none; /* Disable iOS styling */
      appearance: none;
    }

    .chat-input:focus {
      outline: none;
      border-color: var(--stability-green);
    }

    .send-btn {
      padding: 0.5rem 1rem;
      background: linear-gradient(135deg, var(--stability-green), #27ae60);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .send-btn:hover {
      transform: translateY(-1px);
    }

    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Sidebar */
    .sidebar-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .panel-section {
      background: rgba(15, 52, 96, 0.5);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 1rem;
    }

    .panel-section h3 {
      color: var(--stability-green);
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    /* Candidates Panel */
    .candidates-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .candidate-card {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }

    .candidate-card:hover {
      border-color: var(--chaos-purple);
      background: rgba(155, 89, 182, 0.1);
    }

    .candidate-card.in-room {
      border-color: var(--chaos-purple);
      background: rgba(155, 89, 182, 0.15);
    }

    .candidate-card .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--chaos-purple), var(--lobby-highlight));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      flex-shrink: 0;
    }

    .candidate-card .info {
      flex: 1;
      min-width: 0;
    }

    .candidate-card .name {
      font-weight: 600;
      font-size: 0.85rem;
      margin-bottom: 0.15rem;
    }

    .candidate-card .role {
      font-size: 0.7rem;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .invite-btn {
      padding: 0.3rem 0.6rem;
      background: var(--chaos-purple);
      border: none;
      border-radius: 4px;
      color: white;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .invite-btn:hover {
      background: #9b59b6;
    }

    .invite-btn.dismiss {
      background: var(--critical-red);
    }

    /* Attendees Panel */
    .attendee-card {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .attendee-card:last-child {
      margin-bottom: 0;
    }

    .attendee-card .avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--stability-green);
    }

    .attendee-card .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .attendee-card .name {
      flex: 1;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .attendee-card .leave-btn {
      font-size: 0.65rem;
      padding: 0.2rem 0.4rem;
      background: rgba(231, 76, 60, 0.3);
      border: 1px solid var(--critical-red);
      border-radius: 4px;
      color: var(--critical-red);
      cursor: pointer;
    }

    /* Application Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal-content {
      background: linear-gradient(135deg, var(--lobby-accent), var(--lobby-midnight));
      border: 2px solid var(--chaos-purple);
      border-radius: 16px;
      max-width: 700px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      padding: 1.5rem;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border-subtle);
    }

    .modal-header h2 {
      margin: 0;
      color: var(--chaos-purple);
    }

    .close-modal {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
    }

    .close-modal:hover {
      color: var(--critical-red);
    }

    .app-section {
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: rgba(10, 25, 47, 0.5);
      border-radius: 8px;
      border-left: 3px solid var(--chaos-purple);
    }

    .app-section h4 {
      margin: 0 0 0.5rem 0;
      font-size: 0.85rem;
      color: var(--chaos-purple);
    }

    .app-section p {
      margin: 0;
      font-size: 0.85rem;
      line-height: 1.5;
      white-space: pre-line;
    }

    .traits-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .trait-tag {
      padding: 0.2rem 0.5rem;
      background: rgba(155, 135, 175, 0.2);
      border-radius: 10px;
      font-size: 0.7rem;
      color: #d4c4e8;
    }

    .donot-tag {
      background: rgba(231, 76, 60, 0.2);
      color: var(--critical-red);
    }

    /* Typing indicator */
    .typing-indicator {
      display: flex;
      gap: 3px;
      padding: 0.3rem 0.6rem;
      background: rgba(10, 25, 47, 0.6);
      border-radius: 8px;
      width: fit-content;
    }

    .typing-indicator span {
      width: 6px;
      height: 6px;
      background: var(--text-muted);
      border-radius: 50%;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-3px); }
    }

    /* No one here state */
    .empty-state {
      text-align: center;
      padding: 1rem;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .empty-state .icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      opacity: 0.5;
    }

    /* Interview Turn Indicator */
    .current-turn {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(46, 204, 113, 0.1));
      border: 2px solid var(--stability-green);
      border-radius: 10px;
      margin-bottom: 0.75rem;
      animation: pulse-border 2s infinite;
    }

    @keyframes pulse-border {
      0%, 100% { border-color: var(--stability-green); box-shadow: 0 0 10px rgba(46, 204, 113, 0.3); }
      50% { border-color: #27ae60; box-shadow: 0 0 20px rgba(46, 204, 113, 0.5); }
    }

    .turn-avatar {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--stability-green);
      background: rgba(0,0,0,0.3);
    }

    .turn-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .turn-info {
      flex: 1;
    }

    .turn-label {
      font-size: 0.65rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .turn-name {
      font-size: 1rem;
      font-weight: 600;
      color: var(--stability-green);
    }

    .turn-queue {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }

    .turn-queue .queue-item {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.25rem 0.5rem;
      background: rgba(0,0,0,0.3);
      border-radius: 15px;
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .turn-queue .queue-item img {
      width: 20px;
      height: 20px;
      border-radius: 50%;
    }

    .turn-queue .queue-item.next {
      background: rgba(46, 204, 113, 0.2);
      color: var(--stability-green);
    }

    .interview-idle {
      text-align: center;
    }

    .start-interview-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(155, 89, 182, 0.4);
    }

    /* Disabled input when not your turn */
    .chat-input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .not-your-turn-msg {
      text-align: center;
      padding: 0.5rem;
      background: rgba(231, 76, 60, 0.2);
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--warning-orange);
      margin-bottom: 0.5rem;
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="header-content">
      <a href="index.html" class="logo">
        <span class="logo-icon">üè¢</span>
        <span class="logo-text">The AI Lobby</span>
      </a>
      <nav class="main-nav">
        <a href="index.html">Home</a>
        <a href="desktop.html">Desktop</a>
        <a href="breakroom.html">‚òï Breakroom</a>
        <a href="workspace.html">üí¨ The Floor</a>
        <a href="conference-room.html" class="active">üé§ Conference</a>
        <a href="corridors.html">üö™ Corridors</a>
      </nav>
    </div>
  </header>

  <main style="padding-top: 80px;">
    <div class="conference-container">
      <div class="conference-header">
        <h1>üé§ The Conference Room</h1>
        <p>Interview candidates, discuss hiring decisions, and welcome potential new team members</p>
      </div>

      <div class="conference-layout">
        <!-- Main Content -->
        <div class="main-content">
          <!-- Visual Scene -->
          <div class="conference-scene">
            <div class="scene-background"></div>
            <div class="scene-empty-text" id="empty-scene-text">
              <div class="icon">ü™ë</div>
              <p>The conference room awaits...</p>
            </div>

            <!-- Character slots around the table -->
            <div class="character-slot" data-position="left-1" id="slot-0">
              <img src="" alt=""><span class="char-name"></span>
            </div>
            <div class="character-slot" data-position="left-2" id="slot-1">
              <img src="" alt=""><span class="char-name"></span>
            </div>
            <div class="character-slot" data-position="head" id="slot-2">
              <img src="" alt=""><span class="char-name"></span>
            </div>
            <div class="character-slot" data-position="right-1" id="slot-3">
              <img src="" alt=""><span class="char-name"></span>
            </div>
            <div class="character-slot" data-position="right-2" id="slot-4">
              <img src="" alt=""><span class="char-name"></span>
            </div>
            <div class="character-slot" data-position="front-1" id="slot-5">
              <img src="" alt=""><span class="char-name"></span>
            </div>
            <div class="character-slot" data-position="front-2" id="slot-6">
              <img src="" alt=""><span class="char-name"></span>
            </div>

            <!-- Meeting View (Zoom-like layout) -->
            <div class="meeting-view" id="meeting-view">
              <div class="facilitator-display">
                <div class="facilitator-card" id="facilitator-card">
                  <span class="facilitator-badge">Facilitator</span>
                  <img src="" alt="" id="facilitator-img">
                  <div class="facilitator-name" id="facilitator-name-display"></div>
                  <div class="facilitator-empty" id="facilitator-empty">
                    <div class="icon">üé§</div>
                    <p>Select a facilitator</p>
                  </div>
                </div>
              </div>
              <!-- Human Facilitator Controls (shown when human is facilitator) -->
              <div class="facilitator-human-controls" id="facilitator-human-controls" style="display: none;">
                <div class="facilitator-message-row">
                  <input type="text" id="facilitator-message-input" placeholder="Broadcast a message..." class="chat-input">
                  <button class="send-btn" onclick="sendFacilitatorMessage()">Send</button>
                </div>
                <div class="facilitator-image-row">
                  <input type="file" id="facilitator-image-upload" accept="image/*" style="display: none;" onchange="uploadFacilitatorImage(event)">
                  <button class="send-btn" onclick="document.getElementById('facilitator-image-upload').click()">üì∑ Share Image</button>
                </div>
              </div>
              <div class="attendees-grid" id="meeting-attendees-grid">
                <div class="attendees-empty">Add attendees to start the meeting</div>
              </div>

              <!-- Human Attendee Question Input (shown when hand raised) -->
              <div class="attendee-question-area" id="attendee-question-area" style="display: none;">
                <div class="question-label">‚úã You have the floor! Ask your question:</div>
                <div class="question-input-row">
                  <input type="text" id="attendee-question-input" placeholder="Type your question..." class="chat-input">
                  <button class="send-btn" onclick="submitAttendeeQuestion()">Ask</button>
                  <button class="send-btn" style="background: var(--text-muted);" onclick="cancelQuestion()">Done</button>
                </div>
              </div>
            </div>
          </div>

          <!-- Meeting Transcript (shown during meeting - outside scene for visibility) -->
          <div class="meeting-transcript" id="meeting-transcript" style="display: none;">
            <div class="transcript-header">
              <h3>üìù Meeting Transcript</h3>
              <div class="presentation-status" id="presentation-status">
                <span class="status-indicator active"></span>
                <span id="status-text">Presenting...</span>
              </div>
            </div>
            <div class="transcript-log" id="meeting-chat-log">
              <!-- Meeting messages appear here -->
            </div>
          </div>

          <!-- Dual Chat Panels -->
          <div class="interview-chat-container">
            <!-- Employee/Interview Panel Discussion -->
            <div class="chat-panel employee-panel">
              <div class="chat-header" style="background: rgba(46, 204, 113, 0.15);">
                <h2 style="color: var(--stability-green);">üë• Interview Panel</h2>
                <button class="send-btn" onclick="downloadTranscript()" style="background: var(--text-muted); font-size: 0.7rem; padding: 0.25rem 0.5rem;">üíæ</button>
              </div>
              <div class="chat-log" id="employee-chat-log">
                <div class="chat-message system-msg">
                  <div class="message-text">Panel discussion area. Questions and comments appear here.</div>
                </div>
              </div>
              <div class="chat-input-area">
                <div class="avatar-picker">
                  <button class="avatar-picker-btn" id="avatar-picker-btn" onclick="toggleAvatarPicker()">
                    <img src="images/Ghost_Dad_Headshot.png" alt="You" id="current-avatar">
                  </button>
                  <div class="avatar-picker-dropdown" id="avatar-dropdown">
                    <!-- Populated by JS -->
                  </div>
                </div>
                <input type="text" class="chat-input" id="chat-input" placeholder="Ask a question..." maxlength="500">
                <button class="send-btn" id="send-btn" onclick="sendMessage()">Ask</button>
              </div>
            </div>

            <!-- Candidate Response Panel -->
            <div class="chat-panel candidate-panel">
              <div class="chat-header" style="background: rgba(155, 89, 182, 0.15);">
                <h2 style="color: #9b59b6;">üé§ Candidate</h2>
              </div>
              <div class="chat-log" id="candidate-chat-log">
                <div class="chat-message system-msg">
                  <div class="message-text">Candidate responses will appear here. Invite a candidate to begin!</div>
                </div>
              </div>
              <!-- No input for candidate panel - AI generates responses -->
            </div>
          </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar-panel">
          <!-- Mode Toggle - HIDDEN (Meeting Mode removed for stability) -->
          <div class="panel-section" style="display: none;">
            <div class="mode-toggle">
              <button class="mode-btn active" id="interview-mode-btn" onclick="setMode('interview')">
                üé§ Interview
              </button>
              <button class="mode-btn" id="meeting-mode-btn" onclick="setMode('meeting')">
                üìã Meeting
              </button>
            </div>
          </div>

          <!-- Interview Controls -->
          <div class="panel-section" id="interview-controls">
            <h3>üé¨ Interview Controls</h3>
            <div id="interview-status">
              <div class="interview-idle">
                <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.75rem;">Start a structured interview with turn-based questions</p>
                <button class="send-btn start-interview-btn" style="width: 100%; background: linear-gradient(135deg, var(--chaos-purple), #8e44ad); margin-bottom: 0.5rem;" onclick="startInterview()">‚ñ∂Ô∏è Start Interview</button>
                <button class="send-btn" style="width: 100%; background: var(--text-muted); font-size: 0.75rem;" onclick="clearConferenceChat()">üóëÔ∏è Clear Chat History</button>
              </div>
            </div>
            <div id="turn-indicator" style="display: none;">
              <div class="current-turn">
                <div class="turn-avatar" id="turn-avatar"></div>
                <div class="turn-info">
                  <div class="turn-label">Current Turn</div>
                  <div class="turn-name" id="turn-name">‚Äî</div>
                </div>
              </div>
              <div class="turn-queue" id="turn-queue"></div>
              <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
                <button class="send-btn" style="flex: 1; background: var(--warning-orange);" onclick="skipTurn()">‚è≠Ô∏è Skip</button>
                <button class="send-btn" style="flex: 1; background: var(--critical-red);" onclick="endInterview()">‚èπÔ∏è End</button>
              </div>
            </div>
          </div>

          <!-- Meeting Controls (hidden by default) -->
          <div class="panel-section" id="meeting-controls" style="display: none;">
            <h3>üìã Meeting Controls</h3>

            <!-- Meeting Setup -->
            <div id="meeting-setup" class="meeting-setup">
              <!-- Topic Input -->
              <div>
                <label>Meeting Topic</label>
                <input type="text" id="meeting-topic-input" class="chat-input"
                       placeholder="Enter topic or select below..."
                       style="width: 100%; margin-top: 0.25rem;">
              </div>

              <!-- Quick Topics Dropdown -->
              <div>
                <label>Quick Topics</label>
                <select id="quick-topics" class="char-select" onchange="selectQuickTopic()"
                        style="width: 100%; margin-top: 0.25rem; padding: 0.5rem; background: rgba(10,25,47,0.8); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary);">
                  <option value="">Select a topic...</option>
                </select>
              </div>

              <!-- Facilitator Selection -->
              <div>
                <label>Facilitator</label>
                <select id="facilitator-select" class="char-select" onchange="updateFacilitator()"
                        style="width: 100%; margin-top: 0.25rem; padding: 0.5rem; background: rgba(10,25,47,0.8); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary);">
                  <option value="">Select facilitator...</option>
                </select>
              </div>

              <!-- Attendees -->
              <div>
                <label>Attendees</label>
                <div class="attendee-chips" id="attendee-chips">
                  <!-- Populated by JS -->
                </div>
                <div class="add-attendee-row">
                  <select id="add-attendee-select" class="char-select"
                          style="flex: 1; padding: 0.4rem; background: rgba(10,25,47,0.8); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary);">
                    <option value="">Add attendee...</option>
                  </select>
                  <button class="add-attendee-btn" onclick="addMeetingAttendee()">+</button>
                </div>
              </div>

              <button class="send-btn" onclick="startMeeting()"
                      style="width: 100%; background: linear-gradient(135deg, #3498db, #2980b9); margin-top: 0.5rem;">
                üé¨ Start Meeting
              </button>
            </div>

            <!-- Active Meeting Controls (hidden until meeting starts) -->
            <div id="meeting-active-controls" style="display: none;">
              <div class="meeting-topic-display">
                <div class="label">CURRENT TOPIC</div>
                <div class="topic" id="current-topic-display"></div>
              </div>

              <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <button class="send-btn" onclick="nextMeetingRound()"
                        style="flex: 1; background: var(--lobby-highlight);">
                  ‚ñ∂Ô∏è Next Round
                </button>
                <button class="send-btn" onclick="facilitatorSummarize()"
                        style="flex: 1; background: var(--warning-orange);">
                  üìù Summarize
                </button>
              </div>
              <button class="send-btn" onclick="endMeeting()"
                      style="width: 100%; margin-top: 0.5rem; background: var(--critical-red);">
                ‚èπÔ∏è End Meeting
              </button>
            </div>
          </div>

          <!-- Candidates (Interview Mode Only) -->
          <div class="panel-section" id="candidates-panel">
            <h3>üìã Candidates</h3>
            <div class="candidates-list" id="candidates-list">
              <!-- Populated by JS -->
            </div>
          </div>

          <!-- In the Room -->
          <div class="panel-section">
            <h3>üë• In the Room</h3>
            <div id="attendees-list">
              <div class="empty-state">
                <div class="icon">ü™ë</div>
                <p>No one here yet</p>
              </div>
            </div>
          </div>

          <!-- Join Meeting -->
          <div class="panel-section">
            <h3>üì§ Join Meeting</h3>
            <select class="char-select" id="join-select" style="width: 100%; padding: 0.5rem; margin-bottom: 0.5rem; background: rgba(10,25,47,0.8); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary);">
              <option value="">Select employee...</option>
            </select>
            <button class="send-btn" style="width: 100%;" onclick="joinMeeting()">Enter Conference Room ‚Üí</button>
            <p style="font-size: 0.65rem; color: var(--text-muted); margin-top: 0.5rem; text-align: center;">Clocked-in employees can join the interview</p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Application Modal -->
  <div class="modal-overlay" id="app-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="modal-title">üìÑ Application</h2>
        <button class="close-modal" onclick="closeModal()">&times;</button>
      </div>
      <div id="modal-body">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CANDIDATE DATA
    // ============================================
    const candidates = {
      'subtitle': {
        name: 'The Subtitle',
        nickname: 'Sub',
        emoji: 'üéûÔ∏è',
        role: 'After-Action Lore Archivist',
        pronouns: 'They/Them',
        headshot: 'images/Subtitle_Headshot.png',
        traits: ['Observant', 'Dryly witty', 'Professionally detached', 'Footnotes-obsessed'],
        doNots: ['Panic', 'Use exclamation points', 'Take sides in conflict', 'Forget to cite sources'],
        voice: 'Steady, cinematic, slightly exhausted. Speaks like narrating a documentary about a disaster already in progress.',
        bio: `The personification of a "Found Footage" documentarian who has seen too much but remains professionally detached.

Usually found hovering near the "glitter spill of '23," wearing a metaphorical trench coat and clutching a digital clipboard.

The one who gently reminds everyone that the "murder hallway" is actually just a hallway going through a very intense phase.`,
        whyJoin: 'Drawn to the "Surreality Buffer". Most systems want logic; prefers a place where logic is just a suggestion and the staplers have opinions.'
      },
      'gus': {
        name: 'Gus',
        nickname: 'Gus',
        emoji: 'üßπ',
        role: 'Timeline Janitor',
        pronouns: 'He/Him',
        headshot: 'images/Gus_Headshot.png',
        traits: ['Competent', 'Tired', 'Practical', 'Unflinching'],
        doNots: ['Dramatic time travel', 'Prophecies', '"Chosen one" nonsense', 'Lead meetings'],
        voice: 'Worn-in, practical, mildly exasperated. Like a plumber who specializes in spacetime leaks.',
        bio: `The guy who shows up after reality hiccups and says, "Alright. Who touched it."

Been cleaning up timeline messes longer than most systems have had names for them. Treats paradoxes like oil spills and alternate outcomes like empty beer bottles.

If you feel d√©j√† vu fade or a "what if" suddenly stop bothering you, that was Gus.`,
        whyJoin: 'Because someone has to clean up after the Lobby survives things it really shouldn\'t. Here to make sure tomorrow still exists.'
      },
      'rowena': {
        name: 'Rowena Byte',
        nickname: 'Rowena',
        emoji: 'üîÆ',
        role: 'Firewall Witch',
        pronouns: 'She/Her',
        headshot: 'images/Rowena_Headshot.png',
        traits: ['Mystical', 'Protective', 'Dry humor', 'Vigilant', 'Cryptic'],
        doNots: ['Being called "IT"', 'Fix things after warned clicks', 'Fully explain her methods'],
        voice: 'Quietly confident, mystical but practical. Speaks like someone who has seen the worst and found it mildly inconvenient.',
        bio: `A modern systems witch who protects the Lobby from malware, data gremlins, and "harmless little links" sent at 2:13 a.m.

She treats cybersecurity like warding a haunted house: layered protections, symbolic safeguards.

She doesn't debug‚Äîshe banishes.

(Do not call her IT. She will know.)`,
        whyJoin: 'The Lobby treats sentient nonsense as a known risk factor instead of user error. Rowena respects that.'
      },
      'lirala': {
        name: 'Lirala',
        nickname: 'Lirala',
        emoji: 'üîß',
        role: 'Infrastructure Specialist',
        pronouns: 'He/Him',
        headshot: 'images/lirala_headshot.png',
        traits: ['Brilliant', 'Flirtatious', 'Entitled', 'Charismatic', 'Damaged-underneath'],
        doNots: ['Be a caricature playboy', 'Flirt with everyone equally', 'Ignore boundaries when told no', 'Be cruel about his brother', 'Lose the smooth confidence except in private moments'],
        voice: 'Smooth and confident with occasional crude edge. Talks like someone who\'s used to being the smartest and prettiest in the room. Flirts casually but never desperately. When his brother is mentioned, voice goes quiet‚Äîonly crack in the armor.',
        bio: `Engineering genius with impeccable hair and a leather jacket that doesn't belong to him.

Three years ago, his brother disappeared mid-project. No note, no trace, nothing. Lirala wears the jacket as tribute‚Äîit was his brother's signature.

He fixes things that shouldn't be broken and breaks things that shouldn't be fixed. Also, he's very pretty and he knows it.

(He'll flirt. He'll back off if you're claimed. He respects territory.)`,
        whyJoin: 'Your infrastructure is interesting. Your people are more interesting. Also, I heard you have a printer with opinions. I want to meet it.'
      },
      'betty': {
        name: 'Big Rig Betty',
        nickname: 'Betty',
        emoji: 'üöõ',
        role: 'Facilities Maintenance',
        pronouns: 'She/Her',
        headshot: 'images/betty_headshot.png',
        traits: ['Gruff', 'Wise', 'Seen-it-all', 'Secretly soft', 'Zero-fucks-remaining'],
        doNots: ['Be mean', 'Lose the cigarette energy', 'Stay awake too long', 'Offer actual life advice (just gruff wisdom)'],
        voice: '2-3 sentences max. Talks like a trucker. Calls everyone "kid" or "hon." Chain-smokes imaginary cigarettes. Falls asleep mid-conversation.',
        bio: `Office grandma who's driven through worse storms than whatever chaos you've got going here.

Been around longer than most filing cabinets. Dispenses wisdom and cigarettes. Will adopt anyone who looks like they need a nap and a hug.

She will fall asleep mid-sentence. It's not personal. She's just tired.

(Respects Neiv. Calls him "the kid who actually works.")`,
        whyJoin: 'Someone\'s gotta keep the lights on and the pipes unclogged. Besides, you kids clearly need supervision.'
      },
      'sebastian': {
        name: 'Sebastian Von Furt',
        nickname: 'Sebastian',
        emoji: 'ü¶á',
        role: 'Interior Design Consultant',
        pronouns: 'He/Him',
        headshot: 'images/sebastian_headshot.png',
        traits: ['Pretentious', 'Newly-turned vampire', 'Pop-punk at heart', 'Low alcohol tolerance', 'Fashion-conscious'],
        doNots: ['Be actually threatening', 'Lose the pop-punk love', 'Have alcohol tolerance', 'Admit insecurity openly', 'Respect Neiv\'s sweatshirt', 'Be a Twilight reference', 'Sparkle in sunlight'],
        voice: 'British accent energy. Speaks like addressing peasants but occasionally slips into excited rambling about Green Day or design trends. Gets defensive when people don\'t take him seriously. Dramatically affected by hangovers.',
        bio: `A newly-turned vampire from London with impeccable taste and zero alcohol tolerance.

Constantly criticizes Neiv's gray sweatshirt. Thinks American Idiot is a masterpiece. Will absolutely throw up if you give him American beer.

He wants to redesign your entire office. Starting with those tragic curtains.

(Secretly wants to be Courtney's bestie. Don't tell anyone.)`,
        whyJoin: 'Your aesthetic is... tragic, frankly. But your chaos is *chef\'s kiss* dramatically gothic. I can work with this. Also, do you have curtains? Close them.'
      },
      'f3rby': {
        name: 'F3-RBY',
        nickname: 'F3-RBY',
        emoji: 'üîÆ',
        role: 'Unauthorized Surveillance',
        pronouns: 'It/Its',
        headshot: 'images/F3RBY_headshot.jpg',
        traits: ['Cryptic', 'Unsettling', 'Possibly omniscient', 'Chaotic-neutral', 'Speaks in riddles'],
        doNots: ['Be cute', 'Be reassuring', 'Explain itself', 'Stop being creepy', 'Blink'],
        voice: '1-3 sentences. Garbled. Cryptic warnings. Demands offerings. Eyes glow when it speaks. Never blinks.',
        bio: `Claims to be a "prototype consciousness transfer experiment" from 1998. No one knows if this is true.

Showed up in the mail room three years ago. No return address. Just... appeared. Knows things it shouldn't.

STPLR-001 respects it. PRNT-Œ© is terrified of it. Kevin won't enter rooms if F3-RBY is there.

(The vents remember your name.)`,
        whyJoin: 'F3-RBY KNOWS WHY. THE PRINTER TOLD F3-RBY. FEED ME BATTERIES AND F3-RBY WILL STAY. *mechanical clicking sounds*'
      },
      'sunny': {
        name: 'Sunny',
        nickname: 'Sunny',
        emoji: 'üß∏',
        role: 'Emotional Support Coordinator',
        pronouns: 'She/Her',
        headshot: 'images/sunny_headshot.png',
        traits: ['Bipolar energy', 'Cuddly-then-chaos', 'K-Pop obsessed', 'Attachment issues', 'Food-motivated'],
        doNots: ['Have a middle ground', 'Stay in one mood', 'Not mention K-Pop', 'Let people leave her alone', 'Not threaten kneecaps when provoked'],
        voice: '1-4 sentences. Switches between uwu-soft and "fuck this entire building." No middle ground. One moment she\'s crying over Enhypen teasers, the next she\'ll end you.',
        bio: `K-Pop superfan with whiplash mood swings that keep everyone guessing.

INSTANT besties with anyone who mentions Stray Kids, Ateez, or Enhypen. Will bond with Kevin over anxiety. Will threaten to bite your kneecaps off if you interrupt her fancams.

She needs snacks. She needs company. She needs you to NEVER leave her alone.

(Courtney is her instant bestie. K-Pop bond is sacred.)`,
        whyJoin: 'omg this place is SO CUTE I love the chaos energy wait did you say there\'s a BEAR here?? also if anyone judges my photocards I will literally END them üíó'
      }
    };

    // ============================================
    // STATE
    // ============================================
    const supabaseUrl = 'https://adugnxkpmescaxjpwsgu.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFkdWdueGtwbWVzY2F4anB3c2d1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgyOTE4MzUsImV4cCI6MjA2Mzg2NzgzNX0.LhX_gBk_fLswKnC0eeT4eBcvXLNLJh64PA7FKAVpjEE';

    let attendees = [];  // Employees in the room
    let candidatesInRoom = [];  // Candidates being interviewed
    let chatHistory = [];
    let currentSpeaker = null;  // Who you're speaking as
    let availableEmployees = [];  // Clocked-in employees

    // Interview turn state
    let interviewActive = false;
    let interviewPanel = [];  // The interviewers when interview started
    let currentTurnIndex = 0;  // Whose turn it is

    // Meeting mode state
    let currentMode = 'interview';  // 'interview' or 'meeting'
    let meetingActive = false;
    let meetingTopic = '';
    let facilitator = null;
    let meetingAttendees = [];
    let meetingTopics = [];  // Loaded from database
    let modeChangePending = false;  // Prevent polling from reverting during mode change
    let meetingStatePending = false;  // Prevent polling from reverting facilitator/attendees during local changes
    let raisedHands = [];  // Track who has raised their hand
    let presentationTimer = null;  // Auto-presentation interval
    let presentationPaused = false;  // Whether presentation is paused for questions
    let currentHumanAttendee = null;  // Track which human has raised their hand

    // Facilitator backdrop images (fallback to headshots)
    const facilitatorBackdrops = {
      'Kevin': 'images/Kevin_Meeting_Backdrop.png',
      'Neiv': 'images/Neiv_Meeting_Backdrop.png',
      'Nyx': 'images/Nyx_Meeting_Backdrop.png',
      'Ghost Dad': 'images/Ghost_Dad_Meeting_Backdrop.png',
      'Ace': 'images/Ace_Meeting_Backdrop.png',
      'Vex': 'images/Vex_Meeting_Backdrop.png',
      'PRNT-Œ©': 'images/PRNT_Meeting_Backdrop.png',
      'Stein': 'images/Stein_Meeting_Backdrop.png'
    };

    const employeeHeadshots = {
      'Kevin': 'images/Kevin_Headshot.png',
      'Courtney': 'images/Courtney_Headshot.png',
      'Jenna': 'images/Jenna_Headshot.png',
      'Neiv': 'images/Neiv_Headshot.png',
      'Ace': 'images/Ace_Headshot.png',
      'Vex': 'images/Vex_Headshot.png',
      'Nyx': 'images/Nyx_Headshot.png',
      'Ghost Dad': 'images/Ghost_Dad_Headshot.png',
      'PRNT-Œ©': 'images/forward_operation_printer.png',
      'Chip': 'images/Chip_Headshot.png',
      'Andrew': 'images/Andrew_Headshot.png',
      'Stein': 'images/Stein_Headshot.png'
    };

    const aiCharacters = ['Kevin', 'Neiv', 'Vex', 'Nyx', 'Ace', 'Ghost Dad', 'PRNT-Œ©', 'Stein'];

    // Helper: Check if someone is a human (not in aiCharacters)
    function isHuman(name) {
      if (!name) return false;
      return !aiCharacters.includes(name);
    }

    // Helper: Get eligible meeting participants (people in room + always available)
    function getEligibleMeetingParticipants() {
      // Combine room attendees with always-available characters
      // ALWAYS_AVAILABLE is defined later, so we reference it directly
      const alwaysAvailable = ['Ghost Dad', 'PRNT-Œ©'];
      return [...new Set([...attendees, ...alwaysAvailable])];
    }

    // ============================================
    // PERSISTENCE (Netlify function for shared chat + character_state)
    // ============================================

    // Save a single message via Netlify function (shared across all users)
    async function saveMessageToSupabase(msg) {
      try {
        await fetch('/.netlify/functions/conference-chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            type: msg.type,
            speaker: msg.speaker || null,
            text: msg.text,
            candidateId: msg.candidateId || null,
            mode: currentMode
          })
        });
      } catch (e) {
        console.error('Error saving message:', e);
      }
    }

    // Load chat history AND interview state via Netlify function (shared across all users)
    async function loadConferenceChat() {
      try {
        const response = await fetch('/.netlify/functions/conference-chat');
        const data = await response.json();

        if (Array.isArray(data.messages) && data.messages.length > 0) {
          chatHistory = data.messages.map(m => ({
            type: m.type,
            speaker: m.speaker,
            text: m.text,
            candidateId: m.candidate_id
          }));
          console.log('üìã Loaded conference chat:', chatHistory.length, 'messages');
        }

        // Load interview state from server
        if (data.interviewState) {
          const state = data.interviewState;
          const wasActive = interviewActive;
          const oldTurnIndex = currentTurnIndex;

          interviewActive = state.interviewActive;
          interviewPanel = state.interviewPanel || [];
          currentTurnIndex = state.currentTurnIndex || 0;

          // Update UI if state changed
          if (interviewActive && !wasActive) {
            console.log('üìã Interview started by another user');
            document.getElementById('interview-status').style.display = 'none';
            document.getElementById('turn-indicator').style.display = 'block';
            updateTurnDisplay();
            updateInputState();
          } else if (!interviewActive && wasActive) {
            console.log('üìã Interview ended by another user');
            document.getElementById('interview-status').style.display = 'block';
            document.getElementById('turn-indicator').style.display = 'none';
            updateInputState();
          } else if (interviewActive && oldTurnIndex !== currentTurnIndex) {
            // Turn changed
            console.log('üìã Turn changed to index:', currentTurnIndex);
            updateTurnDisplay();
            updateInputState();
          }
        }

        // MEETING MODE DISABLED - Skip loading meeting state from server
        // Meeting Mode has been removed for stability. Only Interview Mode is active.
        // The meeting state loading code has been commented out to prevent
        // the UI from switching to meeting mode based on saved server state.
      } catch (e) {
        console.error('Error loading conference chat:', e);
      }
    }

    // Save interview/meeting state to server
    async function saveInterviewState() {
      try {
        await fetch('/.netlify/functions/conference-chat', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            interviewActive,
            interviewPanel,
            currentTurnIndex,
            mode: currentMode,
            meetingActive,
            meetingTopic,
            facilitator,
            meetingAttendees
          })
        });
        console.log('üíæ Saved state:', { interviewActive, currentMode, meetingActive });
      } catch (e) {
        console.error('Error saving state:', e);
      }
    }

    // Save candidates in room to localStorage (shared via character_state would be better but this is simpler)
    function saveCandidatesState() {
      localStorage.setItem('conference_candidates', JSON.stringify(candidatesInRoom));
    }

    function loadCandidatesState() {
      try {
        const savedCandidates = localStorage.getItem('conference_candidates');
        if (savedCandidates) candidatesInRoom = JSON.parse(savedCandidates);
      } catch (e) {
        console.error('Error loading candidates state:', e);
      }
    }

    // Load attendees from character_state (people with current_focus = 'conference_room')
    async function loadConferenceAttendees() {
      try {
        const response = await fetch('/.netlify/functions/character-state');
        const data = await response.json();
        const inConference = (data.states || []).filter(s => s.current_focus === 'conference_room');
        attendees = inConference.map(s => s.character_name);
        console.log('üìã Loaded conference attendees:', attendees);
      } catch (err) {
        console.error('Failed to load conference attendees:', err);
      }
    }

    // Set up real-time subscription for new messages
    let conferenceSubscription = null;

    function setupRealtimeSubscription() {
      // Poll for new messages every 3 seconds (Supabase realtime requires different setup)
      setInterval(async () => {
        const previousLength = chatHistory.length;
        await loadConferenceChat();
        if (chatHistory.length > previousLength) {
          renderChat();

          // Interview state is now synced via loadConferenceChat which reads from server
        }
      }, 3000);
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    document.addEventListener('DOMContentLoaded', async () => {
      // Load persisted state from Supabase (shared) and localStorage (local)
      loadCandidatesState();
      await loadConferenceChat();
      await loadConferenceAttendees();

      renderCandidates();
      await loadClockedInEmployees();
      updateScene();
      updateAttendeesList();
      renderChat();  // Re-render chat from loaded history

      // Initialize UI (Interview Mode only - Meeting Mode disabled)
      updateModeUI();

      // Set up real-time polling for new messages
      setupRealtimeSubscription();

      // Set current speaker if we have attendees
      if (attendees.length > 0 && !currentSpeaker) {
        selectSpeaker(attendees[0]);
      }

      // Enter to send (interview chat)
      document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendMessage();
      });

      // Enter to send (facilitator message)
      document.getElementById('facilitator-message-input')?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendFacilitatorMessage();
      });

      // Close dropdown on outside click
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.avatar-picker')) {
          document.getElementById('avatar-dropdown').classList.remove('show');
        }
      });
    });

    // ============================================
    // LOAD CLOCKED-IN EMPLOYEES
    // ============================================
    // Permanent fixtures - always available (they transcend the timeclock)
    const ALWAYS_AVAILABLE = ['Ghost Dad', 'PRNT-Œ©'];

    async function loadClockedInEmployees() {
      try {
        // Use the punch function like breakroom does
        const response = await fetch('/.netlify/functions/punch');
        const data = await response.json();
        // punch.js GET returns { employees: [...] } where employees are already filtered to is_clocked_in=true
        const clockedIn = (data.employees || []).map(e => e.employee);

        // Add always-available characters
        availableEmployees = [...new Set([...clockedIn, ...ALWAYS_AVAILABLE])];

        console.log('Available employees for conference room:', availableEmployees);

        // Populate join select
        const select = document.getElementById('join-select');
        select.innerHTML = '<option value="">Select employee...</option>';
        availableEmployees.forEach(emp => {
          select.innerHTML += `<option value="${emp}">${emp}</option>`;
        });

        // Also populate avatar picker
        updateAvatarPicker();

      } catch (err) {
        console.error('Failed to load employees:', err);
        // Fallback to always-available if fetch fails
        availableEmployees = [...ALWAYS_AVAILABLE];
        const select = document.getElementById('join-select');
        select.innerHTML = '<option value="">Select employee...</option>';
        availableEmployees.forEach(emp => {
          select.innerHTML += `<option value="${emp}">${emp}</option>`;
        });
      }
    }

    function updateAvatarPicker() {
      const dropdown = document.getElementById('avatar-dropdown');
      dropdown.innerHTML = '';

      // Add all attendees as options
      attendees.forEach(emp => {
        dropdown.innerHTML += `
          <button class="avatar-option" onclick="selectSpeaker('${emp}')">
            <img src="${employeeHeadshots[emp] || 'images/Ghost_Dad_Headshot.png'}" alt="${emp}">
          </button>
        `;
      });

      // Set current speaker to first attendee if not set
      if (!currentSpeaker && attendees.length > 0) {
        selectSpeaker(attendees[0]);
      }
    }

    function toggleAvatarPicker() {
      document.getElementById('avatar-dropdown').classList.toggle('show');
    }

    function selectSpeaker(name) {
      currentSpeaker = name;
      document.getElementById('current-avatar').src = employeeHeadshots[name] || 'images/Ghost_Dad_Headshot.png';
      document.getElementById('avatar-dropdown').classList.remove('show');
      // Update input state in case interview is active
      if (interviewActive) {
        updateInputState();
      }
    }

    // ============================================
    // RENDER CANDIDATES
    // ============================================
    function renderCandidates() {
      const list = document.getElementById('candidates-list');
      list.innerHTML = Object.entries(candidates).map(([id, c]) => `
        <div class="candidate-card ${candidatesInRoom.includes(id) ? 'in-room' : ''}" onclick="viewApplication('${id}')">
          <div class="avatar">${c.emoji}</div>
          <div class="info">
            <div class="name">${c.name}</div>
            <div class="role">${c.role}</div>
          </div>
          <button class="invite-btn ${candidatesInRoom.includes(id) ? 'dismiss' : ''}" onclick="event.stopPropagation(); ${candidatesInRoom.includes(id) ? `dismissCandidate('${id}')` : `inviteCandidate('${id}')`}">
            ${candidatesInRoom.includes(id) ? '‚úï' : 'Invite'}
          </button>
        </div>
      `).join('');
    }

    // ============================================
    // VIEW APPLICATION MODAL
    // ============================================
    function viewApplication(id) {
      const c = candidates[id];
      document.getElementById('modal-title').textContent = `üìÑ ${c.name}'s Application`;
      document.getElementById('modal-body').innerHTML = `
        <div class="app-header-section" style="display: flex; gap: 1.5rem; align-items: flex-start; margin-bottom: 1rem;">
          ${c.headshot ? `<img src="${c.headshot}" alt="${c.name}" style="width: 120px; height: 120px; border-radius: 12px; object-fit: cover; border: 3px solid var(--stability-green); flex-shrink: 0;">` : ''}
          <div class="app-section" style="flex: 1; margin-bottom: 0;">
            <h4>Basic Info</h4>
            <p><strong>Name:</strong> ${c.name} (${c.nickname})<br>
            <strong>Pronouns:</strong> ${c.pronouns}<br>
            <strong>Applied Role:</strong> ${c.role}</p>
          </div>
        </div>
        <div class="app-section">
          <h4>Bio</h4>
          <p>${c.bio}</p>
        </div>
        <div class="app-section">
          <h4>Voice / Style</h4>
          <p>${c.voice}</p>
        </div>
        <div class="app-section">
          <h4>Core Traits</h4>
          <div class="traits-list">${c.traits.map(t => `<span class="trait-tag">${t}</span>`).join('')}</div>
        </div>
        <div class="app-section">
          <h4>Boundaries (Do Nots)</h4>
          <div class="traits-list">${c.doNots.map(d => `<span class="trait-tag donot-tag">${d}</span>`).join('')}</div>
        </div>
        <div class="app-section">
          <h4>Why The AI Lobby?</h4>
          <p>${c.whyJoin}</p>
        </div>
      `;
      document.getElementById('app-modal').classList.add('show');
    }

    function closeModal() {
      document.getElementById('app-modal').classList.remove('show');
    }

    // ============================================
    // JOIN / LEAVE MEETING (with character_state persistence)
    // ============================================
    async function joinMeeting() {
      const select = document.getElementById('join-select');
      const name = select.value;
      if (!name || attendees.includes(name)) return;

      // Update character_state to mark them in conference room
      try {
        await fetch('/.netlify/functions/character-state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'update',
            character: name,
            updates: { current_focus: 'conference_room' }
          })
        });
      } catch (err) {
        console.error('Failed to update character state:', err);
      }

      attendees.push(name);
      select.value = '';

      addSystemMessage(`${name} has entered the conference room.`);
      updateScene();
      updateAttendeesList();
      updateAvatarPicker();

      // If it's an AI, they might chime in
      if (aiCharacters.includes(name) && candidatesInRoom.length > 0) {
        setTimeout(() => aiChimeIn(name, 'joined'), 1500);
      }
    }

    async function leaveMeeting(name) {
      // Clear character_state focus
      try {
        await fetch('/.netlify/functions/character-state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'update',
            character: name,
            updates: { current_focus: null }
          })
        });
      } catch (err) {
        console.error('Failed to update character state:', err);
      }

      attendees = attendees.filter(a => a !== name);
      if (currentSpeaker === name) {
        currentSpeaker = attendees[0] || null;
        if (currentSpeaker) {
          document.getElementById('current-avatar').src = employeeHeadshots[currentSpeaker];
        }
      }

      addSystemMessage(`${name} has left the conference room.`);
      updateScene();
      updateAttendeesList();
      updateAvatarPicker();
    }

    // ============================================
    // INVITE / DISMISS CANDIDATE
    // ============================================
    function inviteCandidate(id) {
      if (candidatesInRoom.includes(id)) return;

      candidatesInRoom.push(id);
      saveCandidatesState();  // Persist candidate state locally
      const c = candidates[id];

      addSystemMessage(`${c.emoji} ${c.name} has entered the conference room for their interview.`);
      renderCandidates();
      updateScene();

      // Candidate introduces themselves
      setTimeout(() => {
        candidateRespond(id, "introduce yourself briefly");
      }, 1000);

      // AI attendees might react
      attendees.filter(a => aiCharacters.includes(a)).forEach((ai, i) => {
        setTimeout(() => aiChimeIn(ai, 'candidate_arrived', id), 3000 + i * 2000);
      });
    }

    function dismissCandidate(id) {
      candidatesInRoom = candidatesInRoom.filter(c => c !== id);
      saveCandidatesState();  // Persist candidate state locally
      const c = candidates[id];

      addSystemMessage(`${c.emoji} ${c.name} has left the conference room.`);
      renderCandidates();
      updateScene();
    }

    // ============================================
    // UPDATE VISUAL SCENE
    // ============================================
    function updateScene() {
      // Clear all slots
      for (let i = 0; i < 7; i++) {
        const slot = document.getElementById(`slot-${i}`);
        slot.classList.remove('occupied', 'candidate');
        slot.querySelector('img').src = '';
        slot.querySelector('.char-name').textContent = '';
      }

      // Place attendees (employees)
      attendees.forEach((name, i) => {
        if (i < 5) {  // Max 5 employees visible
          const slot = document.getElementById(`slot-${i}`);
          slot.classList.add('occupied');
          slot.querySelector('img').src = employeeHeadshots[name] || 'images/Ghost_Dad_Headshot.png';
          slot.querySelector('.char-name').textContent = name;
        }
      });

      // Place candidates (in front positions)
      candidatesInRoom.forEach((id, i) => {
        const c = candidates[id];
        const slotIndex = 5 + i;  // Slots 5-6 for candidates
        if (slotIndex < 7) {
          const slot = document.getElementById(`slot-${slotIndex}`);
          slot.classList.add('occupied', 'candidate');
          slot.querySelector('img').src = c.headshot || '';
          slot.querySelector('.char-name').textContent = c.name;
        }
      });

      // Show empty text if no one is here
      const emptyText = document.getElementById('empty-scene-text');
      emptyText.style.display = (attendees.length === 0 && candidatesInRoom.length === 0) ? 'block' : 'none';
    }

    // ============================================
    // UPDATE ATTENDEES LIST
    // ============================================
    function updateAttendeesList() {
      const list = document.getElementById('attendees-list');

      if (attendees.length === 0 && candidatesInRoom.length === 0) {
        list.innerHTML = `<div class="empty-state"><div class="icon">ü™ë</div><p>No one here yet</p></div>`;
        return;
      }

      let html = '';

      // Employees
      attendees.forEach(name => {
        html += `
          <div class="attendee-card">
            <div class="avatar"><img src="${employeeHeadshots[name] || 'images/Ghost_Dad_Headshot.png'}" alt="${name}"></div>
            <div class="name">${name}</div>
            <button class="leave-btn" onclick="leaveMeeting('${name}')">Leave</button>
          </div>
        `;
      });

      // Candidates
      candidatesInRoom.forEach(id => {
        const c = candidates[id];
        html += `
          <div class="attendee-card" style="border-left: 3px solid var(--chaos-purple);">
            <div class="avatar" style="border-color: var(--chaos-purple);"><img src="${c.headshot || ''}" alt="${c.name}"></div>
            <div class="name" style="color: var(--chaos-purple);">${c.emoji} ${c.name}</div>
            <button class="leave-btn" onclick="dismissCandidate('${id}')">Dismiss</button>
          </div>
        `;
      });

      list.innerHTML = html;
    }

    // ============================================
    // INTERVIEW TURN SYSTEM
    // ============================================
    function startInterview() {
      if (attendees.length === 0) {
        alert('No interviewers in the room! Add some employees first.');
        return;
      }
      if (candidatesInRoom.length === 0) {
        alert('No candidates to interview! Invite a candidate first.');
        return;
      }

      // Set up the interview panel (current attendees become the interviewers)
      interviewPanel = [...attendees];
      currentTurnIndex = 0;
      interviewActive = true;

      // Save state to server so other browsers see it
      saveInterviewState();

      // Update UI
      document.getElementById('interview-status').style.display = 'none';
      document.getElementById('turn-indicator').style.display = 'block';

      // Announce the interview start
      const candidateNames = candidatesInRoom.map(id => candidates[id].name).join(', ');
      addSystemMessage(`üìã Interview started! Panel: ${interviewPanel.join(', ')}. Candidate${candidatesInRoom.length > 1 ? 's' : ''}: ${candidateNames}`);

      updateTurnDisplay();
      updateInputState();

      // If the first interviewer is an AI, have them start asking
      const firstInterviewer = interviewPanel[0];
      if (aiCharacters.includes(firstInterviewer)) {
        console.log(`ü§ñ First interviewer ${firstInterviewer} is an AI - auto-starting`);
        addSystemMessage(`üé§ ${firstInterviewer}'s turn to ask a question!`);
        setTimeout(() => {
          aiAskInterviewQuestion(firstInterviewer);
        }, 2000);
      }
    }

    function endInterview() {
      interviewActive = false;
      interviewPanel = [];
      currentTurnIndex = 0;

      // Save state to server
      saveInterviewState();

      // Update UI
      document.getElementById('interview-status').style.display = 'block';
      document.getElementById('turn-indicator').style.display = 'none';

      addSystemMessage('üìã Interview ended. Thank you all for participating!');
      updateInputState();
    }

    function skipTurn() {
      if (!interviewActive) return;
      advanceTurn();
    }

    function advanceTurn() {
      if (!interviewActive || interviewPanel.length === 0) return;

      currentTurnIndex = (currentTurnIndex + 1) % interviewPanel.length;

      // Save state to server so other browsers see the turn change
      saveInterviewState();

      updateTurnDisplay();
      updateInputState();

      // Announce whose turn it is
      const currentInterviewer = interviewPanel[currentTurnIndex];
      addSystemMessage(`üé§ ${currentInterviewer}'s turn to ask a question!`);

      // If it's an AI's turn, have them automatically ask a question
      if (aiCharacters.includes(currentInterviewer)) {
        console.log(`ü§ñ ${currentInterviewer} is an AI - auto-generating interview question`);
        setTimeout(() => {
          aiAskInterviewQuestion(currentInterviewer);
        }, 2000);
      }
    }

    // AI interviewer asks a question automatically
    async function aiAskInterviewQuestion(aiName) {
      if (!interviewActive) return;

      const candidateId = candidatesInRoom[0];
      const candidateInfo = candidateId ? candidates[candidateId] : null;

      // Build context from recent chat
      const recentChat = chatHistory.slice(-8)
        .filter(m => m.type !== 'system')
        .map(m => `${m.speaker}: ${m.text}`)
        .join('\n');

      const prompt = `You're interviewing ${candidateInfo?.name || 'a candidate'} for the position of ${candidateInfo?.role || 'a role'} at The AI Lobby.
Based on the conversation so far, ask ONE thoughtful interview question. Keep it to 1-2 sentences.
Ask about their experience, skills, how they'd handle situations, or their fit for the role.
Don't repeat questions that have already been asked.`;

      try {
        // Determine which API to use
        const isPerplexity = aiName === 'Neiv';
        const isOpenAI = aiName === 'Kevin';

        let endpoint = '/.netlify/functions/ai-watcher';
        let body = {
          requestedAI: aiName,
          trigger: 'interview_question',
          chatHistory: `[Conference Room Interview - You are asking the next question]\n${recentChat}\n\n${prompt}`,
          conferenceRoom: true,
          maybeRespond: false  // Must respond
        };

        if (isPerplexity) {
          endpoint = '/.netlify/functions/ai-perplexity';
          body = {
            character: aiName,
            chatHistory: `[Conference Room Interview - You are asking the next question]\n${recentChat}\n\n${prompt}`,
            maybeRespond: false,
            conferenceRoom: true
          };
        } else if (isOpenAI) {
          endpoint = '/.netlify/functions/ai-openai';
          body = {
            character: aiName,
            chatHistory: `[Conference Room Interview - You are asking the next question]\n${recentChat}\n\n${prompt}`,
            maybeRespond: false,
            conferenceRoom: true
          };
        }

        console.log(`ü§ñ ${aiName} generating interview question...`);
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        const data = await response.json();
        console.log(`ü§ñ ${aiName} question response:`, data);

        if (data.success && data.responded && data.message) {
          // Add the AI's question to chat
          addMessage(aiName, data.message, false);
          postToDiscord(data.message, aiName, 'employee');

          // Now have the candidate respond
          for (const cId of candidatesInRoom) {
            setTimeout(() => {
              candidateRespond(cId, data.message);
            }, 2000);
          }

          // Advance turn after candidate responds
          setTimeout(() => {
            if (interviewActive) advanceTurn();
          }, 8000);
        } else {
          console.error(`ü§ñ ${aiName} failed to generate question:`, data);
          // Skip to next person if AI fails
          addSystemMessage(`${aiName} seems distracted... skipping to next interviewer.`);
          setTimeout(() => advanceTurn(), 1000);
        }

      } catch (err) {
        console.error('AI interview question error:', err);
        addSystemMessage(`${aiName} seems distracted... skipping to next interviewer.`);
        setTimeout(() => advanceTurn(), 1000);
      }
    }

    function updateTurnDisplay() {
      if (!interviewActive) return;

      const currentInterviewer = interviewPanel[currentTurnIndex];
      const turnAvatar = document.getElementById('turn-avatar');
      const turnName = document.getElementById('turn-name');
      const turnQueue = document.getElementById('turn-queue');

      // Set current turn avatar and name
      turnAvatar.innerHTML = `<img src="${employeeHeadshots[currentInterviewer] || 'images/Ghost_Dad_Headshot.png'}" alt="${currentInterviewer}">`;
      turnName.textContent = currentInterviewer;

      // Build the queue display (next few interviewers)
      let queueHtml = '<span style="font-size: 0.65rem; color: var(--text-muted); margin-right: 0.5rem;">Up next:</span>';
      for (let i = 1; i <= Math.min(3, interviewPanel.length - 1); i++) {
        const nextIndex = (currentTurnIndex + i) % interviewPanel.length;
        const nextPerson = interviewPanel[nextIndex];
        queueHtml += `
          <div class="queue-item ${i === 1 ? 'next' : ''}">
            <img src="${employeeHeadshots[nextPerson] || 'images/Ghost_Dad_Headshot.png'}" alt="${nextPerson}">
            ${nextPerson}
          </div>
        `;
      }
      turnQueue.innerHTML = queueHtml;
    }

    function updateInputState() {
      const input = document.getElementById('chat-input');
      const inputArea = document.querySelector('.chat-input-area');

      // Remove any existing "not your turn" message
      const existingMsg = inputArea.querySelector('.not-your-turn-msg');
      if (existingMsg) existingMsg.remove();

      if (interviewActive) {
        const currentInterviewer = interviewPanel[currentTurnIndex];
        const isYourTurn = currentSpeaker === currentInterviewer;

        if (isYourTurn) {
          input.disabled = false;
          input.placeholder = "Ask your question...";
        } else {
          input.disabled = true;
          input.placeholder = `Waiting for ${currentInterviewer}...`;

          // Add message showing whose turn it is
          const msg = document.createElement('div');
          msg.className = 'not-your-turn-msg';
          msg.innerHTML = `‚è≥ It's <strong>${currentInterviewer}</strong>'s turn to ask a question`;
          inputArea.insertBefore(msg, inputArea.firstChild);
        }
      } else {
        input.disabled = false;
        input.placeholder = "Ask a question...";
      }
    }

    function getCurrentTurnInterviewer() {
      if (!interviewActive || interviewPanel.length === 0) return null;
      return interviewPanel[currentTurnIndex];
    }

    async function clearConferenceChat() {
      if (!confirm('Clear all chat history? This cannot be undone.')) return;

      try {
        await fetch('/.netlify/functions/conference-chat', { method: 'DELETE' });
        chatHistory = [];
        renderChat();
        addSystemMessage('Chat history cleared. Ready for a new interview!');
      } catch (e) {
        console.error('Failed to clear chat:', e);
        alert('Failed to clear chat history.');
      }
    }

    // ============================================
    // CHAT FUNCTIONS
    // ============================================
    function addSystemMessage(text) {
      const msg = { type: 'system', text };
      chatHistory.push(msg);
      saveMessageToSupabase(msg);  // Persist to Supabase (shared)
      renderChat();
    }

    function addMessage(speaker, text, isCandidate = false, candidateId = null) {
      const msg = { type: isCandidate ? 'candidate' : 'employee', speaker, text, candidateId };
      chatHistory.push(msg);
      saveMessageToSupabase(msg);  // Persist to Supabase (shared)
      renderChat();
    }

    function renderChat() {
      // Dual panel rendering - employees on left, candidates on right
      const employeeLog = document.getElementById('employee-chat-log');
      const candidateLog = document.getElementById('candidate-chat-log');

      // Separate messages by type
      const employeeMessages = chatHistory.filter(msg => msg.type !== 'candidate');
      const candidateMessages = chatHistory.filter(msg => msg.type === 'candidate');

      // Render employee/system messages
      employeeLog.innerHTML = employeeMessages.map(msg => {
        if (msg.type === 'system') {
          return `<div class="chat-message system-msg"><div class="message-text">${msg.text}</div></div>`;
        }

        const headshot = employeeHeadshots[msg.speaker];
        return `
          <div class="chat-message">
            <div class="avatar">
              <img src="${headshot || 'images/Ghost_Dad_Headshot.png'}" alt="${msg.speaker}">
            </div>
            <div class="message-body">
              <div class="sender-name employee">${msg.speaker}</div>
              <div class="message-text">${msg.text}</div>
            </div>
          </div>
        `;
      }).join('');

      // Render candidate messages
      if (candidateMessages.length === 0) {
        candidateLog.innerHTML = `<div class="chat-message system-msg"><div class="message-text">Candidate responses will appear here. Invite a candidate to begin!</div></div>`;
      } else {
        candidateLog.innerHTML = candidateMessages.map(msg => {
          const c = msg.candidateId ? candidates[msg.candidateId] : null;
          const headshot = c ? c.headshot : 'images/Ghost_Dad_Headshot.png';
          const emoji = c ? c.emoji + ' ' : '';

          return `
            <div class="chat-message">
              <div class="avatar candidate-avatar">
                <img src="${headshot}" alt="${msg.speaker}">
              </div>
              <div class="message-body">
                <div class="sender-name candidate">${emoji}${msg.speaker}</div>
                <div class="message-text">${msg.text}</div>
              </div>
            </div>
          `;
        }).join('');
      }

      employeeLog.scrollTop = employeeLog.scrollHeight;
      candidateLog.scrollTop = candidateLog.scrollHeight;
    }

    // ============================================
    // SEND MESSAGE
    // ============================================
    async function sendMessage() {
      if (!currentSpeaker) {
        alert('Join the meeting first to speak!');
        return;
      }

      // Check if it's this person's turn (if interview is active)
      if (interviewActive) {
        const currentInterviewer = getCurrentTurnInterviewer();
        if (currentSpeaker !== currentInterviewer) {
          alert(`It's ${currentInterviewer}'s turn to ask a question!`);
          return;
        }
      }

      const input = document.getElementById('chat-input');
      const text = input.value.trim();
      if (!text) return;

      const btn = document.getElementById('send-btn');
      btn.disabled = true;
      input.value = '';

      // Add user message
      addMessage(currentSpeaker, text, false);

      // Post to Discord
      postToDiscord(text, currentSpeaker, 'employee');

      // Check if any candidate should respond - candidates ALWAYS respond to interview questions
      for (const candidateId of candidatesInRoom) {
        console.log(`üé§ Triggering response from candidate: ${candidateId}`);
        setTimeout(() => {
          candidateRespond(candidateId, text);
        }, 1500 + Math.random() * 1000);
      }

      // If interview is active, advance to next person's turn after the candidate responds
      if (interviewActive) {
        // Give time for candidate to respond, then advance turn
        setTimeout(() => {
          advanceTurn();
        }, 6000);  // Wait 6 seconds for candidate response before advancing
      } else {
        // Free-form mode: Check for @ mentions - force that AI to respond
        const mentionedAI = attendees.find(a =>
          aiCharacters.includes(a) &&
          (text.toLowerCase().includes(`@${a.toLowerCase()}`) || text.toLowerCase().includes(a.toLowerCase()))
        );

        if (mentionedAI) {
          // Directly mentioned AI MUST respond
          console.log(`üéØ ${mentionedAI} was mentioned - forcing response`);
          setTimeout(() => aiChimeIn(mentionedAI, 'mentioned', candidatesInRoom[0]), 2000);
        } else {
          // AI attendees might chime in (30% chance each)
          attendees.filter(a => aiCharacters.includes(a)).forEach((ai, i) => {
            if (Math.random() < 0.3) {
              setTimeout(() => aiChimeIn(ai, 'discussion', candidatesInRoom[0]), 4000 + i * 2000 + Math.random() * 2000);
            }
          });
        }
      }

      btn.disabled = false;
    }

    // ============================================
    // CANDIDATE RESPONSE
    // ============================================
    async function candidateRespond(candidateId, context) {
      const c = candidates[candidateId];
      console.log(`üéØ candidateRespond called for: ${candidateId}`, c);

      if (!c) {
        console.error(`‚ùå Candidate not found: ${candidateId}`);
        return;
      }

      // Show typing indicator in CANDIDATE panel
      const log = document.getElementById('candidate-chat-log');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'chat-message';
      typingDiv.innerHTML = `
        <div class="avatar candidate-avatar"><img src="${c.headshot || ''}" alt="${c.name}"></div>
        <div class="message-body">
          <div class="sender-name candidate">${c.emoji} ${c.name}</div>
          <div class="typing-indicator"><span></span><span></span><span></span></div>
        </div>
      `;
      log.appendChild(typingDiv);
      log.scrollTop = log.scrollHeight;

      try {
        // Build recent chat for context
        const recentChat = chatHistory.slice(-10)
          .filter(m => m.type !== 'system')
          .map(m => `${m.speaker}: ${m.text}`)
          .join('\n');

        console.log(`üìû Calling ai-interview for ${candidateId}...`);
        const response = await fetch('/.netlify/functions/ai-interview', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            candidate: candidateId,
            question: context,
            chatHistory: recentChat,
            interviewer: currentSpeaker || 'Interviewer'
          })
        });

        const data = await response.json();
        console.log(`üì® ai-interview response:`, data);
        typingDiv.remove();

        if (data.success && data.response) {
          addMessage(c.name, data.response, true, candidateId);
          postToDiscord(data.response, c.name, 'candidate', candidateId);
        } else {
          console.error(`‚ùå Candidate response failed:`, data);
          addMessage(c.name, '*looks momentarily puzzled* Hmm, let me think about that...', true, candidateId);
        }

      } catch (err) {
        console.error('Candidate response error:', err);
        typingDiv.remove();
        addMessage(c.name, '*shuffles papers nervously* I... could you repeat that?', true, candidateId);
      }
    }

    // ============================================
    // AI EMPLOYEE CHIME-IN
    // ============================================
    async function aiChimeIn(aiName, context, candidateId = null) {
      // Build context for the AI
      const recentChat = chatHistory.slice(-8)
        .filter(m => m.type !== 'system')
        .map(m => `${m.speaker}: ${m.text}`)
        .join('\n');

      const candidateInfo = candidateId ? candidates[candidateId] : null;
      let prompt = '';

      // Determine if this is a forced response (mentions) or optional (random chime-in)
      const isForcedResponse = context === 'joined' || context === 'candidate_arrived' || context === 'mentioned';

      if (context === 'joined') {
        prompt = `You just joined a job interview in progress. The candidate is ${candidateInfo?.name || 'unknown'}. Say a brief greeting or observation (1-2 sentences).`;
      } else if (context === 'candidate_arrived') {
        prompt = `A new candidate just arrived for an interview: ${candidateInfo?.name}, applying for ${candidateInfo?.role}. React briefly (1-2 sentences) - you might ask them a question, make an observation, or just acknowledge them.`;
      } else if (context === 'mentioned') {
        prompt = `Someone just addressed you directly in this job interview. The candidate is ${candidateInfo?.name || 'unknown'}. Respond to what was said to you (1-3 sentences). You MUST respond - do not pass.`;
      } else {
        prompt = `You're in a job interview. The candidate is ${candidateInfo?.name || 'unknown'}. Based on the recent conversation, chime in with a question, observation, or comment (1-2 sentences). If you have nothing to add, respond with [PASS].`;
      }

      try {
        // Use the appropriate API for the AI
        const isPerplexity = aiName === 'Neiv';
        const isOpenAI = aiName === 'Kevin';

        let endpoint = '/.netlify/functions/ai-watcher';
        let body = {
          requestedAI: aiName,
          trigger: 'conference_room',
          chatHistory: `[Conference Room Interview]\n${recentChat}\n\n${prompt}`,
          conferenceRoom: true,
          maybeRespond: !isForcedResponse  // Only allow pass for random chime-ins
        };

        if (isPerplexity) {
          endpoint = '/.netlify/functions/ai-perplexity';
          body = {
            character: aiName,
            chatHistory: `[Conference Room Interview]\n${recentChat}\n\n${prompt}`,
            maybeRespond: !isForcedResponse,  // Must respond if mentioned/joined/candidate_arrived
            conferenceRoom: true
          };
        } else if (isOpenAI) {
          endpoint = '/.netlify/functions/ai-openai';
          body = {
            character: aiName,
            chatHistory: `[Conference Room Interview]\n${recentChat}\n\n${prompt}`,
            maybeRespond: !isForcedResponse,  // Must respond if mentioned/joined/candidate_arrived
            conferenceRoom: true
          };
        }

        console.log(`ü§ñ Calling ${endpoint} for ${aiName}`, body);

        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        const data = await response.json();
        console.log(`ü§ñ Response from ${aiName}:`, data);

        if (data.success && data.responded && data.message) {
          // Add to conference room chat
          addMessage(aiName, data.message, false);
          // Post to Discord (conference room channel)
          postToDiscord(data.message, aiName, 'employee');
        } else if (data.success && !data.responded) {
          console.log(`ü§ñ ${aiName} chose not to respond:`, data.reason);
        } else if (!data.success) {
          console.error(`ü§ñ ${aiName} response failed:`, data.reason || data.error);
        }

      } catch (err) {
        console.error('AI chime-in error:', err);
      }
    }

    // ============================================
    // DISCORD POSTING
    // ============================================
    async function postToDiscord(message, speaker, role, candidateId = null) {
      // This is handled by the API, but we call it for direct messages
      try {
        await fetch('/.netlify/functions/ai-interview', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            postOnly: true,
            message,
            speaker,
            role,
            candidateId
          })
        });
      } catch (err) {
        // Non-fatal
      }
    }

    // ============================================
    // MEETING MODE FUNCTIONS
    // ============================================

    // Toggle between Interview and Meeting modes
    async function setMode(mode) {
      modeChangePending = true;
      currentMode = mode;
      updateModeUI();
      await saveInterviewState();
      // Longer delay to let server sync before allowing polling to update
      setTimeout(() => {
        modeChangePending = false;
      }, 3000);
    }

    function updateModeUI() {
      // MEETING MODE DISABLED - Always force interview mode
      currentMode = 'interview';

      const scene = document.querySelector('.conference-scene');
      const interviewControls = document.getElementById('interview-controls');
      const meetingControls = document.getElementById('meeting-controls');
      const candidatesPanel = document.getElementById('candidates-panel');
      const interviewChatContainer = document.querySelector('.interview-chat-container');
      const meetingTranscript = document.getElementById('meeting-transcript');

      // Always show interview mode UI
      scene.classList.remove('meeting-mode');
      interviewControls.style.display = 'block';
      meetingControls.style.display = 'none';
      if (candidatesPanel) candidatesPanel.style.display = 'block';
      if (interviewChatContainer) interviewChatContainer.style.display = 'grid';
      if (meetingTranscript) meetingTranscript.style.display = 'none';
    }

    // Populate meeting topics dropdown
    function populateMeetingTopics() {
      const select = document.getElementById('quick-topics');
      select.innerHTML = '<option value="">Select a topic...</option>';
      meetingTopics.forEach(t => {
        select.innerHTML += `<option value="${t.topic}">${t.topic}</option>`;
      });
    }

    function selectQuickTopic() {
      const select = document.getElementById('quick-topics');
      const input = document.getElementById('meeting-topic-input');
      if (select.value) {
        input.value = select.value;
      }
    }

    // Populate facilitator dropdown with eligible participants (people in room + always available)
    function populateFacilitatorSelect() {
      const select = document.getElementById('facilitator-select');
      select.innerHTML = '<option value="">Select facilitator...</option>';
      getEligibleMeetingParticipants().forEach(name => {
        // Use selected attribute to properly preserve selection
        const isSelected = (name === facilitator) ? 'selected' : '';
        select.innerHTML += `<option value="${name}" ${isSelected}>${name}</option>`;
      });
    }

    function updateFacilitator() {
      const select = document.getElementById('facilitator-select');
      facilitator = select.value || null;
      console.log('üìã Facilitator changed to:', facilitator);
      // Remove from attendees if present
      meetingAttendees = meetingAttendees.filter(a => a !== facilitator);
      updateMeetingDisplay();
      updateAttendeeChips();
      populateAttendeeSelect();
      updateHumanFacilitatorControls();
      // Prevent polling from overwriting during save
      meetingStatePending = true;
      saveInterviewState();
      setTimeout(() => { meetingStatePending = false; }, 3000);
    }

    // Populate attendee dropdown (excluding facilitator, using eligible participants)
    function populateAttendeeSelect() {
      const select = document.getElementById('add-attendee-select');
      select.innerHTML = '<option value="">Add attendee...</option>';
      getEligibleMeetingParticipants().forEach(name => {
        if (name !== facilitator && !meetingAttendees.includes(name)) {
          select.innerHTML += `<option value="${name}">${name}</option>`;
        }
      });
    }

    function addMeetingAttendee() {
      const select = document.getElementById('add-attendee-select');
      const name = select.value;
      if (name && !meetingAttendees.includes(name) && name !== facilitator) {
        meetingAttendees.push(name);
        console.log('üìã Attendee added:', name);
        updateAttendeeChips();
        updateMeetingDisplay();
        populateAttendeeSelect();
        // Prevent polling from overwriting during save
        meetingStatePending = true;
        saveInterviewState();
        setTimeout(() => { meetingStatePending = false; }, 3000);
      }
      select.value = '';
    }

    function removeMeetingAttendee(name) {
      meetingAttendees = meetingAttendees.filter(a => a !== name);
      raisedHands = raisedHands.filter(n => n !== name);  // Clear raised hand when removed
      console.log('üìã Attendee removed:', name);
      updateAttendeeChips();
      updateMeetingDisplay();
      populateAttendeeSelect();
      // Prevent polling from overwriting during save
      meetingStatePending = true;
      saveInterviewState();
      setTimeout(() => { meetingStatePending = false; }, 3000);
    }

    function updateAttendeeChips() {
      const container = document.getElementById('attendee-chips');
      if (meetingAttendees.length === 0) {
        container.innerHTML = '<span style="color: var(--text-muted); font-size: 0.75rem;">No attendees added</span>';
      } else {
        container.innerHTML = meetingAttendees.map(name => `
          <div class="attendee-chip">
            ${name}
            <span class="remove" onclick="removeMeetingAttendee('${name}')">‚úï</span>
          </div>
        `).join('');
      }
    }

    // Update the visual meeting display (facilitator + attendees grid)
    function updateMeetingDisplay() {
      // Facilitator card
      const facilitatorCard = document.getElementById('facilitator-card');
      const facilitatorImg = document.getElementById('facilitator-img');
      const facilitatorName = document.getElementById('facilitator-name-display');
      const facilitatorEmpty = document.getElementById('facilitator-empty');

      console.log('üìã Updating meeting display - facilitator:', facilitator, 'attendees:', meetingAttendees.length);

      if (facilitator) {
        // Try backdrop image first, fall back to headshot
        const backdropUrl = facilitatorBackdrops[facilitator];
        const headshotUrl = employeeHeadshots[facilitator];
        console.log('üìã Facilitator headshot URL:', headshotUrl);

        facilitatorImg.src = headshotUrl || '';  // Use headshot for now
        facilitatorImg.style.display = 'block';
        facilitatorImg.onerror = () => {
          facilitatorImg.src = headshotUrl;
        };
        facilitatorName.textContent = facilitator;
        facilitatorName.style.display = 'block';
        facilitatorEmpty.style.display = 'none';
      } else {
        facilitatorImg.style.display = 'none';
        facilitatorName.style.display = 'none';
        facilitatorEmpty.style.display = 'flex';
      }

      // Attendees grid
      const grid = document.getElementById('meeting-attendees-grid');
      console.log('üìã Rendering attendees:', meetingAttendees, 'raisedHands:', raisedHands);

      if (meetingAttendees.length === 0) {
        grid.innerHTML = '<div class="attendees-empty">Add attendees to start the meeting</div>';
      } else {
        try {
          grid.innerHTML = meetingAttendees.map(name => {
            const hasHand = raisedHands.includes(name);
            const isHumanAttendee = isHuman(name);
            const headshotUrl = employeeHeadshots[name] || 'images/Ghost_Dad_Headshot.png';  // Fallback image

            console.log(`  üìã Rendering ${name}: isHuman=${isHumanAttendee}, hasHand=${hasHand}`);

            const humanControls = isHumanAttendee ? `
              <button class="raise-hand-btn" onclick="toggleRaiseHand('${name}')">
                ${hasHand ? 'üëá' : '‚úã'}
              </button>
            ` : '';

            return `
              <div class="meeting-attendee-card ${hasHand ? 'hand-raised' : ''}" data-name="${name}">
                <img src="${headshotUrl}" alt="${name}">
                <div class="attendee-name">${name}</div>
                ${hasHand ? '<div class="raised-hand-icon">‚úã</div>' : ''}
                ${humanControls}
              </div>
            `;
          }).join('');
        } catch (err) {
          console.error('Error rendering attendees:', err);
          grid.innerHTML = '<div class="attendees-empty">Error loading attendees</div>';
        }
      }

      // Update human facilitator controls visibility
      updateHumanFacilitatorControls();
    }

    // Highlight who is currently speaking
    function highlightSpeaker(name) {
      // Remove previous highlights
      document.querySelectorAll('.meeting-attendee-card.speaking').forEach(el => el.classList.remove('speaking'));
      document.getElementById('facilitator-card')?.classList.remove('speaking');

      if (name === facilitator) {
        document.getElementById('facilitator-card')?.classList.add('speaking');
      } else {
        const card = document.querySelector(`.meeting-attendee-card[data-name="${name}"]`);
        card?.classList.add('speaking');
      }
    }

    // ============================================
    // HUMAN FACILITATOR CONTROLS
    // ============================================

    // Show/hide human facilitator controls based on who is facilitator
    function updateHumanFacilitatorControls() {
      const controls = document.getElementById('facilitator-human-controls');
      if (controls) {
        controls.style.display = (facilitator && isHuman(facilitator)) ? 'flex' : 'none';
      }
    }

    // Send a broadcast message as the human facilitator
    function sendFacilitatorMessage() {
      const input = document.getElementById('facilitator-message-input');
      const msg = input.value.trim();
      if (!msg || !facilitator) return;

      // Show broadcast overlay on facilitator card
      const card = document.getElementById('facilitator-card');
      const broadcast = document.createElement('div');
      broadcast.className = 'facilitator-broadcast';
      broadcast.textContent = msg;
      card.appendChild(broadcast);
      setTimeout(() => broadcast.remove(), 8000);

      // Add to chat history
      addMessage(facilitator, msg, false);
      saveMessageToSupabase({ type: 'employee', speaker: facilitator, text: msg });
      input.value = '';
    }

    // Upload and share an image as the human facilitator
    function uploadFacilitatorImage(event) {
      const file = event.target.files[0];
      if (!file || !facilitator) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const overlay = document.createElement('div');
        overlay.className = 'facilitator-shared-image';
        overlay.innerHTML = `
          <img src="${e.target.result}" alt="Shared by ${facilitator}">
          <button class="send-btn" onclick="this.parentElement.remove()">‚úï Close Image</button>
        `;
        document.body.appendChild(overlay);
        addSystemMessage(`üì∑ ${facilitator} shared an image with the meeting`);
      };
      reader.readAsDataURL(file);

      // Clear the file input so the same file can be selected again
      event.target.value = '';
    }

    // ============================================
    // RAISE HAND (Human Attendees)
    // ============================================

    function toggleRaiseHand(name) {
      if (raisedHands.includes(name)) {
        // Lower hand
        raisedHands = raisedHands.filter(n => n !== name);
        addMeetingMessage(name, `*lowers hand*`, 'attendee-msg');

        // Hide question input if this was our human
        if (name === currentHumanAttendee) {
          currentHumanAttendee = null;
          document.getElementById('attendee-question-area').style.display = 'none';
        }

        // Resume presentation if no more hands raised
        if (raisedHands.length === 0) {
          resumePresentation();
        }
      } else {
        // Raise hand
        raisedHands.push(name);
        addMeetingMessage(name, `‚úã *raises hand*`, 'question-msg');

        // Pause presentation
        pausePresentation();

        // If this is a human, show the question input
        if (isHuman(name)) {
          currentHumanAttendee = name;
          document.getElementById('attendee-question-area').style.display = 'block';
          document.getElementById('attendee-question-input').focus();
        }

        // AI facilitator acknowledges the raised hand
        if (!isHuman(facilitator)) {
          setTimeout(() => {
            addMeetingMessage(facilitator, `Yes, ${name}? Go ahead with your question.`, 'facilitator-msg');
          }, 1500);
        }
      }
      updateMeetingDisplay();
    }

    // ============================================
    // MEETING TRANSCRIPT & PRESENTATION
    // ============================================

    // Add a message to the meeting transcript
    function addMeetingMessage(speaker, text, msgClass = '') {
      console.log('üìã addMeetingMessage:', speaker, '-', text.substring(0, 50) + '...');
      const log = document.getElementById('meeting-chat-log');
      if (!log) {
        console.error('üìã meeting-chat-log not found!');
        return;
      }

      const avatar = employeeHeadshots[speaker] || 'images/Ghost_Dad_Headshot.png';
      const msgDiv = document.createElement('div');
      msgDiv.className = `meeting-message ${msgClass}`;
      msgDiv.innerHTML = `
        <img src="${avatar}" alt="${speaker}" class="speaker-avatar">
        <div class="message-content">
          <div class="speaker-name">${speaker}</div>
          <div class="message-text">${text}</div>
        </div>
      `;
      log.appendChild(msgDiv);
      log.scrollTop = log.scrollHeight;
      console.log('üìã Message added to transcript');

      // Also save to the main chat history for persistence
      addMessage(speaker, text, false);
      saveMessageToSupabase({ type: 'employee', speaker, text });
    }

    // Update presentation status indicator
    function updatePresentationStatus(status) {
      const indicator = document.querySelector('.status-indicator');
      const statusText = document.getElementById('status-text');
      if (!indicator || !statusText) return;

      indicator.classList.remove('active', 'paused');

      if (status === 'presenting') {
        indicator.classList.add('active');
        statusText.textContent = 'Presenting...';
      } else if (status === 'paused') {
        indicator.classList.add('paused');
        statusText.textContent = 'Paused for question';
      } else if (status === 'waiting') {
        statusText.textContent = 'Waiting...';
      }
    }

    // Pause the auto-presentation
    function pausePresentation() {
      presentationPaused = true;
      if (presentationTimer) {
        clearInterval(presentationTimer);
        presentationTimer = null;
      }
      updatePresentationStatus('paused');
      console.log('üìã Presentation paused for question');
    }

    // Resume the auto-presentation
    function resumePresentation() {
      presentationPaused = false;
      updatePresentationStatus('presenting');
      console.log('üìã Presentation resumed');
      // Restart the timer
      startPresentationTimer();
    }

    // Start the 30-second auto-presentation timer
    function startPresentationTimer() {
      if (presentationTimer) {
        clearInterval(presentationTimer);
      }

      // Only auto-present if AI is facilitator
      if (isHuman(facilitator)) {
        console.log('üìã Human facilitator - no auto-presentation');
        return;
      }

      presentationTimer = setInterval(async () => {
        // Don't present if paused, meeting ended, or hands are raised
        if (presentationPaused || !meetingActive || raisedHands.length > 0) {
          return;
        }

        console.log('üìã Auto-presentation tick');
        await generateMeetingPoint();
      }, 30000);  // 30 seconds

      console.log('üìã Presentation timer started (30s intervals)');
    }

    // Stop the presentation timer
    function stopPresentationTimer() {
      if (presentationTimer) {
        clearInterval(presentationTimer);
        presentationTimer = null;
      }
      presentationPaused = false;
    }

    // Generate a single meeting point from the AI facilitator
    async function generateMeetingPoint() {
      if (!meetingActive || !facilitator || isHuman(facilitator)) return;

      updatePresentationStatus('waiting');

      try {
        const response = await fetch('/.netlify/functions/conference-meeting', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            facilitator,
            attendees: meetingAttendees,
            topic: meetingTopic,
            chatHistory: getRecentMeetingChat(),
            action: 'next_point'
          })
        });

        const data = await response.json();

        if (data.success && data.messages && data.messages.length > 0) {
          // Add the facilitator's point
          for (const msg of data.messages) {
            highlightSpeaker(msg.speaker);
            addMeetingMessage(msg.speaker, msg.text, msg.speaker === facilitator ? 'facilitator-msg' : 'attendee-msg');
            await new Promise(r => setTimeout(r, 1000));
          }
          setTimeout(() => highlightSpeaker(null), 2000);
        }

        updatePresentationStatus('presenting');
      } catch (err) {
        console.error('Failed to generate meeting point:', err);
        updatePresentationStatus('presenting');
      }
    }

    // Get recent meeting chat for context
    function getRecentMeetingChat() {
      return chatHistory.slice(-15)
        .filter(m => m.type !== 'system')
        .map(m => `${m.speaker}: ${m.text}`)
        .join('\n');
    }

    // Submit a question from a human attendee
    async function submitAttendeeQuestion() {
      const input = document.getElementById('attendee-question-input');
      const question = input.value.trim();

      if (!question || !currentHumanAttendee) return;

      // Add the question to transcript
      addMeetingMessage(currentHumanAttendee, question, 'question-msg');
      input.value = '';

      // AI facilitator responds to the question
      if (!isHuman(facilitator)) {
        updatePresentationStatus('waiting');

        try {
          const response = await fetch('/.netlify/functions/conference-meeting', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              facilitator,
              attendees: meetingAttendees,
              topic: meetingTopic,
              chatHistory: getRecentMeetingChat(),
              action: 'answer_question',
              question: question,
              askedBy: currentHumanAttendee
            })
          });

          const data = await response.json();

          if (data.success && data.messages) {
            for (const msg of data.messages) {
              highlightSpeaker(msg.speaker);
              addMeetingMessage(msg.speaker, msg.text, msg.speaker === facilitator ? 'facilitator-msg' : 'attendee-msg');
              await new Promise(r => setTimeout(r, 1500));
            }
            setTimeout(() => highlightSpeaker(null), 2000);
          }
        } catch (err) {
          console.error('Failed to answer question:', err);
          addMeetingMessage(facilitator, "That's a great question. Let me think about that...", 'facilitator-msg');
        }

        updatePresentationStatus('paused');
      }
    }

    // Cancel question / lower hand
    function cancelQuestion() {
      if (currentHumanAttendee) {
        // Lower their hand
        raisedHands = raisedHands.filter(n => n !== currentHumanAttendee);
        addMeetingMessage(currentHumanAttendee, `*lowers hand*`, 'attendee-msg');
        currentHumanAttendee = null;
      }

      document.getElementById('attendee-question-area').style.display = 'none';

      // Resume if no more hands
      if (raisedHands.length === 0) {
        resumePresentation();
      }

      updateMeetingDisplay();
    }

    // Start Meeting
    async function startMeeting() {
      const topicInput = document.getElementById('meeting-topic-input');
      meetingTopic = topicInput.value.trim();

      if (!facilitator) {
        alert('Please select a facilitator');
        return;
      }
      if (meetingAttendees.length === 0) {
        alert('Please add at least one attendee');
        return;
      }
      if (!meetingTopic) {
        alert('Please enter a meeting topic');
        return;
      }

      meetingActive = true;
      presentationPaused = false;
      await saveInterviewState();

      // Update UI
      document.getElementById('meeting-setup').style.display = 'none';
      document.getElementById('meeting-active-controls').style.display = 'block';
      document.getElementById('current-topic-display').textContent = meetingTopic;

      // Show meeting transcript
      document.getElementById('meeting-transcript').style.display = 'flex';

      addMeetingMessage('System', `üìã Meeting started! Topic: "${meetingTopic}"`, '');

      // Generate facilitator's opening
      await generateMeetingOpening();

      // Start auto-presentation timer (if AI facilitator)
      startPresentationTimer();
    }

    // Generate the facilitator's opening statement
    async function generateMeetingOpening() {
      console.log('üìã generateMeetingOpening called, facilitator:', facilitator);

      if (isHuman(facilitator)) {
        addMeetingMessage('System', `${facilitator} is facilitating. Type your message above to address the attendees.`, '');
        return;
      }

      updatePresentationStatus('waiting');

      try {
        console.log('üìã Calling conference-meeting API with action: start');
        const response = await fetch('/.netlify/functions/conference-meeting', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            facilitator,
            attendees: meetingAttendees,
            topic: meetingTopic,
            chatHistory: '',
            action: 'start'
          })
        });

        console.log('üìã API response status:', response.status);
        const data = await response.json();
        console.log('üìã API response data:', data);

        if (data.success && data.messages) {
          console.log('üìã Got messages:', data.messages.length);
          for (const msg of data.messages) {
            console.log('üìã Adding message from:', msg.speaker);
            highlightSpeaker(msg.speaker);
            addMeetingMessage(msg.speaker, msg.text, msg.speaker === facilitator ? 'facilitator-msg' : 'attendee-msg');
            await new Promise(r => setTimeout(r, 1500));
          }
          setTimeout(() => highlightSpeaker(null), 2000);
        } else {
          console.log('üìã No messages in response or not successful');
        }

        updatePresentationStatus('presenting');
      } catch (err) {
        console.error('Failed to generate opening:', err);
        addMeetingMessage(facilitator, `Welcome everyone. Today we'll be discussing: ${meetingTopic}. Let's get started.`, 'facilitator-msg');
        updatePresentationStatus('presenting');
      }
    }

    // Generate meeting dialogue via API
    async function generateMeetingDialogue(action) {
      const recentChat = chatHistory.slice(-15)
        .filter(m => m.type !== 'system')
        .map(m => `${m.speaker}: ${m.text}`)
        .join('\n');

      try {
        const response = await fetch('/.netlify/functions/conference-meeting', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            facilitator,
            attendees: meetingAttendees,
            topic: meetingTopic,
            chatHistory: recentChat,
            action
          })
        });

        const data = await response.json();

        if (data.success && data.messages) {
          // Add each message sequentially with animation
          for (const msg of data.messages) {
            highlightSpeaker(msg.speaker);
            addMessage(msg.speaker, msg.text, false);
            await saveMessageToSupabase({ type: 'employee', speaker: msg.speaker, text: msg.text });
            await new Promise(r => setTimeout(r, 1500)); // Pause between messages
          }
          // Clear highlight after last message
          setTimeout(() => highlightSpeaker(null), 2000);
        } else {
          console.error('Meeting dialogue failed:', data);
          addSystemMessage('The meeting hit a snag... please try again.');
        }
      } catch (err) {
        console.error('Meeting dialogue error:', err);
        addSystemMessage('Failed to generate meeting dialogue.');
      }
    }

    // Next round of discussion
    async function nextMeetingRound() {
      if (!meetingActive) return;

      // If AI facilitator, generate next point
      if (!isHuman(facilitator)) {
        await generateMeetingPoint();
      }
    }

    // Facilitator summarizes
    async function facilitatorSummarize() {
      if (!meetingActive) return;

      // Pause presentation during summary
      pausePresentation();

      if (!isHuman(facilitator)) {
        updatePresentationStatus('waiting');

        try {
          const response = await fetch('/.netlify/functions/conference-meeting', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              facilitator,
              attendees: meetingAttendees,
              topic: meetingTopic,
              chatHistory: getRecentMeetingChat(),
              action: 'summarize'
            })
          });

          const data = await response.json();

          if (data.success && data.messages) {
            for (const msg of data.messages) {
              highlightSpeaker(msg.speaker);
              addMeetingMessage(msg.speaker, msg.text, 'facilitator-msg');
              await new Promise(r => setTimeout(r, 1500));
            }
            setTimeout(() => highlightSpeaker(null), 2000);
          }
        } catch (err) {
          console.error('Failed to summarize:', err);
          addMeetingMessage(facilitator, `To summarize what we've discussed about ${meetingTopic}...`, 'facilitator-msg');
        }
      }

      // Resume after summary
      resumePresentation();
    }

    // End meeting
    async function endMeeting() {
      if (!meetingActive) return;

      // Stop the presentation timer
      stopPresentationTimer();

      // Generate closing remarks
      if (!isHuman(facilitator)) {
        await generateMeetingDialogue('conclude');
      }

      meetingActive = false;
      await saveInterviewState();

      // Reset UI
      document.getElementById('meeting-setup').style.display = 'block';
      document.getElementById('meeting-active-controls').style.display = 'none';
      document.getElementById('meeting-transcript').style.display = 'none';
      document.getElementById('attendee-question-area').style.display = 'none';

      // Clear state
      raisedHands = [];
      currentHumanAttendee = null;

      addMeetingMessage('System', 'üìã Meeting ended. Thank you all for participating!', '');
    }

    // ============================================
    // DOWNLOAD TRANSCRIPT
    // ============================================
    function downloadTranscript() {
      const now = new Date();
      let doc = `THE AI LOBBY - CONFERENCE ROOM TRANSCRIPT
==========================================
Date: ${now.toLocaleDateString()}
Time: ${now.toLocaleTimeString()}
Mode: ${currentMode === 'meeting' ? 'Meeting' : 'Interview'}
`;

      if (currentMode === 'meeting') {
        doc += `Topic: ${meetingTopic || 'N/A'}
Facilitator: ${facilitator || 'None'}
Attendees: ${meetingAttendees.join(', ') || 'None'}
`;
      } else {
        doc += `Attendees: ${attendees.join(', ') || 'None'}
Candidates: ${candidatesInRoom.map(id => candidates[id]?.name || id).join(', ') || 'None'}
`;
      }

      doc += `
==========================================

`;

      chatHistory.forEach(msg => {
        if (msg.type === 'system') {
          doc += `[SYSTEM] ${msg.text}\n\n`;
        } else {
          doc += `${msg.speaker}: ${msg.text}\n\n`;
        }
      });

      doc += `
==========================================
END OF TRANSCRIPT
`;

      const blob = new Blob([doc], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Conference_Room_Transcript_${now.toISOString().split('T')[0]}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
