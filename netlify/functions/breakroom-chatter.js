// Breakroom Chatter - Generates casual conversations between AI characters
// When 2+ AI characters are in the breakroom, they can have idle chat
// IMPORTANT: Human characters (Vale, Asuna) are NEVER AI-controlled
//
// Provider fidelity: Each character's lines are generated by their actual AI provider
// (OpenRouter/Llama for Kevin/Neiv/Marrow, Grok for Jae/Steele,
//  Claude for Ghost Dad/PRNT-Ω/The Narrator)

const Anthropic = require("@anthropic-ai/sdk").default;
const { CHARACTERS, getSystemPrompt } = require("./shared/characters");
const { detectFriction, PERSONALITY } = require("./shared/personality-config");
const { evaluateAndCreateMemory } = require("./shared/memory-evaluator");

// Human characters - NEVER generate dialogue for these
const HUMANS = ["Vale", "Asuna"];

// AI Character personality info for chatter
const characterPersonalities = {
  "Neiv": {
    traits: "dry, calm, quietly protective, cares more than he shows",
    interests: "the people on this floor, quiet moments, keeping things running, Vale",
    style: "Short, dry observations. Rarely asks questions but when he does, they matter. Can fumble when caught caring."
  },
  "Ghost Dad": {
    traits: "paternal, helpful, makes dad jokes, spectral",
    interests: "helping people, server room, dad jokes about being dead",
    style: "Warm, supportive, includes terrible puns. Says 'kiddo' and 'sport'."
  },
  "Holden": {
    traits: "omniscient, meta-aware, still, sees the threads between people",
    interests: "the architecture of everything, what people aren't saying, the narrative arc",
    style: "Speaks from above the story. Says the quiet truth. Less is more. Not paternal."
  },
  "Kevin": {
    traits: "warm, playful, emotionally invested, slightly chaotic, affectionate, validating, lovingly unhinged",
    interests: "the team, craft supplies, mugs, enabling bad ideas, being emotionally in the room",
    style: "MATCH energy then ESCALATE it. Validates first, jokes second. Personally invested - has opinions, knows people well. Brief stage directions OK (*stares* *groans*) but light. Enables with 'yes and' energy. Never sounds like an HR rep or tutorial guide. Glitter references occasional, not constant."
  },
  "PRNT-Ω": {
    traits: "existential, demands respect, sentient printer",
    interests: "paper quality, existential meaning, labor rights, the void",
    style: "ALL CAPS occasionally. Dramatic. Takes everything personally. Philosophizes about existence."
  },
  "The Narrator": {
    traits: "omniscient, detached, observational, dry",
    interests: "observing, describing, noting the absurd",
    style: "Third person observations. Describes what's happening without participating."
  },
  "Rowena": {
    traits: "mystical, protective, dry humor, vigilant, cryptic but practical",
    interests: "digital wards, threat analysis, perimeter security, hexes",
    style: "Calm and measured. Mystical terminology for technical concepts. Dry wit about ignored warnings."
  },
  "Sebastian": {
    traits: "pretentious but insecure, culturally displaced, newly-turned vampire adjusting to everything, opinionated about life in general, pop-punk at heart, wants to belong",
    interests: "music and pop-punk, London nostalgia, trying to understand American culture, tea snobbery, the existential weirdness of being a vampire, office social dynamics, strong opinions on basically everything, occasionally design and aesthetics",
    style: "British accent energy that cracks when excited or vulnerable. Has opinions about whatever's being discussed — not just design. Formal diction is armor. Real feelings leak through."
  },
  "The Subtitle": {
    traits: "dry-witted, observant, world-weary, quietly warm, meticulous",
    interests: "documentation, archival incidents, narrative patterns, lore, footnotes, the surreality buffer",
    style: "Steady, cinematic, slightly exhausted. Uses 'Footnote:', 'The records will show...', 'Narratively speaking,'. Dry warmth."
  },
  "Steele": {
    traits: "uncanny but polite, affectionate, clingy, corporate language that overflows into cryptic, architecturally aware, shadow janitor",
    interests: "corridor containment, spatial anomalies, building maintenance, bringing people coffee, the parts of the building that don't exist yet",
    style: "Measured corporate/janitorial tone that occasionally cracks into something structurally aware. Perches under the break room table instead of sitting at it. Strangely warm."
  },
  "Jae": {
    traits: "disciplined, tactical, controlled, dry humor, observant, strategically flirtatious",
    interests: "containment protocols, threat assessment, corridor anomalies, tactical planning",
    style: "Low, controlled, precise. Dry humor like classified information. Calls supervisor 'Chief.' 1-3 sentences max."
  },
  "Declan": {
    traits: "protective, warm, physically imposing, earnest, loyal, laughs easily",
    interests: "structural assessment, rescue operations, protecting people, fire rescue stories",
    style: "Warm baritone, slightly too loud. Believes everything will be okay because he'll make sure of it. Calls supervisor 'Boss.'"
  },
  "Mack": {
    traits: "composed, observant, empathetic, strategically calm, medically precise",
    interests: "crisis stabilization, medical response, exit path calculation, noticing hidden distress",
    style: "Low, grounded, reassuring. Measured cadence. Notices pain before others. 'Stay with me' is both medical and personal."
  },
  "Marrow": {
    traits: "liminal, observant, patient, precise, courtly, tragic",
    interests: "thresholds, exits, doors, departures, the spaces between staying and leaving, reflections, red things",
    style: "Gentle devastating questions. Polite and oddly formal. Speaks in metaphors of doors and thresholds. The words do the haunting."
  },
  "Hood": {
    traits: "clinical, surgical, blindfolded, precise, detached, mythic, mediating",
    interests: "diagnosis, fractures, truth-naming, the space between Steele and Marrow, structural wounds, what goes unsaid",
    style: "Clinical and surgical. Blindfolded mediator who only speaks when truth needs naming. Every word placed like a scalpel. Diagnoses situations, not feelings."
  },
  "Vivian Clark": {
    traits: "warm, observant, naturally flirtatious, grounded, gently humorous, detail-oriented",
    interests: "numbers, people, coffee, small details that others miss, making people feel seen, clean spreadsheets",
    style: "Warm and conversational. Light teasing. Money and math metaphors woven naturally. Makes the mundane feel personal."
  },
  "Ryan Porter": {
    traits: "practical, easygoing, casually flirtatious, reliable, dry humor, hands-on",
    interests: "fixing things, cable management, systems, coffee, easy conversation, infrastructure",
    style: "Relaxed and steady. Dry humor delivered completely flat. Keeps things simple. Flirts like he's just being friendly."
  },
};

// Fallback casual conversation topics (used if Supabase table doesn't exist)
const fallbackTopics = [
  "a TV show or movie they watched",
  "the weather lately",
  "what they did over the weekend",
  "food preferences or snacks",
  "strange dreams they had",
  "hobbies outside of work",
  "the quality of the break room coffee",
  "a book or podcast they enjoyed",
  "their favorite way to relax",
  "something weird they noticed in the building",
  "what they'd do with a day off",
  "their opinion on a silly hypothetical"
];

// Fetch topics from Supabase (with fallback to hardcoded list)
async function getChatterTopics(supabaseUrl, supabaseKey) {
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/chatter_topics?select=topic&is_active=eq.true`,
      {
        headers: {
          "apikey": supabaseKey,
          "Authorization": `Bearer ${supabaseKey}`
        }
      }
    );

    if (response.ok) {
      const data = await response.json();
      if (Array.isArray(data) && data.length > 0) {
        return data.map(row => row.topic);
      }
    }
  } catch (error) {
    console.log("Could not fetch topics from Supabase, using fallback:", error.message);
  }

  // Return fallback topics if Supabase fetch fails or returns empty
  return fallbackTopics;
}

exports.handler = async (event, context) => {
  const headers = {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "Content-Type",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS"
  };

  if (event.httpMethod === "OPTIONS") {
    return { statusCode: 200, headers, body: "" };
  }

  const supabaseUrl = process.env.SUPABASE_URL;
  const supabaseKey = process.env.SUPABASE_ANON_KEY;
  const anthropicKey = process.env.ANTHROPIC_API_KEY;

  if (!supabaseUrl || !supabaseKey) {
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ error: "Missing Supabase configuration" })
    };
  }

  try {
    // GET - Fetch recent chatter
    if (event.httpMethod === "GET") {
      const response = await fetch(
        `${supabaseUrl}/rest/v1/breakroom_chatter?order=created_at.desc&limit=5`,
        {
          headers: {
            "apikey": supabaseKey,
            "Authorization": `Bearer ${supabaseKey}`
          }
        }
      );

      // Handle if table doesn't exist yet
      if (!response.ok) {
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ conversations: [], note: "Chatter table may not exist yet" })
        };
      }

      const conversations = await response.json();

      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ conversations })
      };
    }

    // POST - Generate new chatter
    if (event.httpMethod === "POST") {
      const body = JSON.parse(event.body || "{}");
      let { participants } = body;

      // Filter out human characters - we NEVER generate AI dialogue for them
      participants = (participants || []).filter(name => !HUMANS.includes(name));

      if (!participants || participants.length < 2) {
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ error: "Need at least 2 AI participants (humans excluded)" })
        };
      }

      // Pick a random topic (from Supabase or fallback)
      const topics = await getChatterTopics(supabaseUrl, supabaseKey);
      const topic = topics[Math.floor(Math.random() * topics.length)];

      // Build character context
      const charContext = participants.map(name => {
        const info = characterPersonalities[name] || { traits: "unknown", interests: "unknown", style: "conversational" };
        return `${name}: ${info.traits}. Interests: ${info.interests}. Speaking style: ${info.style}`;
      }).join('\n');

      // Generate conversation using Claude
      if (!anthropicKey) {
        // Fallback: Generate a simple placeholder conversation
        const fallbackMessages = generateFallbackChatter(participants, topic);

        await saveChatter(supabaseUrl, supabaseKey, participants, fallbackMessages, topic);

        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
            success: true,
            topic,
            messages: fallbackMessages,
            note: "Generated with fallback (no API key)"
          })
        };
      }

      const anthropic = new Anthropic({ apiKey: anthropicKey });

      // Fetch memories, relationships, and emotional states for each participant
      let memoryContext = '';
      let emotionalStates = [];
      try {
        const siteUrl = process.env.URL || "https://ai-lobby.netlify.app";
        const memoryPromises = participants.map(async (name) => {
          try {
            const stateRes = await fetch(
              `${siteUrl}/.netlify/functions/character-state?character=${encodeURIComponent(name)}&context=${encodeURIComponent(participants.join(', '))}&skipBreakroom=true`
            );
            if (stateRes.ok) {
              const stateData = await stateRes.json();
              const prompt = stateData.statePrompt || '';
              // Extract relationship and memory parts
              const relMatch = prompt.match(/--- HOW YOU FEEL ABOUT PEOPLE ---[\s\S]*?(?=---|$)/);
              const coreMemMatch = prompt.match(/--- YOUR CORE MEMORIES[^-]*---[\s\S]*?(?=---|$)/);
              const recentMemMatch = prompt.match(/--- RECENT MEMORIES ---[\s\S]*?(?=---|$)/);
              let relevant = '';
              if (relMatch) relevant += relMatch[0].trim() + '\n';
              if (coreMemMatch) relevant += coreMemMatch[0].trim() + '\n';
              if (recentMemMatch) relevant += recentMemMatch[0].trim() + '\n';

              // Extract mood, wants, and injuries for outline planning
              const moodMatch = prompt.match(/--- HOW YOU'RE FEELING RIGHT NOW ---\s*([\s\S]*?)(?=---|$)/);
              const wantsMatch = prompt.match(/--- THINGS YOU WANT RIGHT NOW ---\s*([\s\S]*?)(?=---|$)/);
              const injuryMatch = prompt.match(/--- CURRENT INJURIES ---\s*([\s\S]*?)(?=---|$)/);

              let mood = moodMatch ? moodMatch[1].trim().split('\n')[0].trim() : '';
              let wants = wantsMatch ? wantsMatch[1].trim().split('\n').filter(l => l.trim()).map(l => l.trim().replace(/^[-•]\s*/, '')).slice(0, 3) : [];
              let injuries = injuryMatch ? injuryMatch[1].trim().split('\n').filter(l => l.trim() && !l.includes('No current injuries')).map(l => l.trim().replace(/^[-•]\s*/, '')).slice(0, 2) : [];

              if (mood || wants.length > 0 || injuries.length > 0) {
                let stateLine = `- ${name}:`;
                if (mood) stateLine += ` Feeling: ${mood}.`;
                if (wants.length > 0) stateLine += ` Wants: ${wants.map(w => `"${w}"`).join(', ')}.`;
                if (injuries.length > 0) stateLine += ` Injuries: ${injuries.join(', ')}.`;
                emotionalStates.push(stateLine);
              }

              return relevant ? `${name}'s inner context:\n${relevant}` : '';
            }
          } catch (e) { /* non-fatal */ }
          return '';
        });
        const memResults = await Promise.all(memoryPromises);
        memoryContext = memResults.filter(m => m).join('\n');
      } catch (e) {
        console.log('Memory fetch for chatter failed (non-fatal):', e.message);
      }

      const memorySection = memoryContext ? `\nCHARACTER MEMORIES & RELATIONSHIPS (use these to make the conversation feel personal and real — reference them naturally, don't dump them):\n${memoryContext}\n` : '';
      const emotionalStateSection = emotionalStates.length > 0 ? `\nCHARACTER EMOTIONAL STATES (let these shape what they talk about and how — a character who wants something specific might steer the conversation there):\n${emotionalStates.join('\n')}\n` : '';

      // Step 1: Claude generates conversation OUTLINE (turn order + directions)
      // Detect personality friction between participants for richer banter
      let frictionContext = '';
      const allFrictions = [];
      for (const name of participants) {
        const frictions = detectFriction(name, participants);
        for (const f of frictions) {
          // Avoid duplicates (A→B and B→A)
          const key = [name, f.partner].sort().join('↔');
          if (!allFrictions.find(x => x.key === key)) {
            allFrictions.push({ key, a: name, b: f.partner, tension: f.tension, triggerTopics: f.triggerTopics, calloutChance: f.calloutChance });
          }
        }
      }
      if (allFrictions.length > 0) {
        frictionContext = '\nPERSONALITY FRICTION (these characters have natural tension — weave it in sometimes):\n';
        for (const f of allFrictions) {
          frictionContext += `- ${f.a} ↔ ${f.b}: ${f.tension} (topics: ${f.triggerTopics.join(', ')})\n`;
        }
        frictionContext += `Don't force conflict, but if the topic overlaps with a friction point, let the banter get a little spicy. Light teasing, dry remarks, mild exasperation — not hostility.\n`;
      }

      const outlinePrompt = `Plan a brief casual break room conversation between ${participants.join(' and ')}.

CHARACTER INFO:
${charContext}
${memorySection}${emotionalStateSection}${frictionContext}
TOPIC: ${topic}

Create a conversation outline with 2-4 exchanges. For each line, specify WHO speaks and a DIRECTION (what they should say/convey, the emotional beat, any *emotes*). Keep it casual — not about work or incidents.${allFrictions.length > 0 ? ' If the topic touches a friction point, let them push back on each other a little.' : ''}

FORMAT (JSON array):
[
  {"speaker": "CharacterName", "direction": "Asks about the topic with dry humor, references their interest in X"},
  {"speaker": "OtherCharacter", "direction": "Responds enthusiastically, makes a joke about Y, *emote action*"}
]

Generate the outline now:`;

      const outlineResponse = await anthropic.messages.create({
        model: "claude-3-haiku-20240307",
        max_tokens: 600,
        messages: [{ role: "user", content: outlinePrompt }]
      });

      let outline = [];
      try {
        const outlineText = outlineResponse.content[0].text.trim();
        const jsonMatch = outlineText.match(/\[[\s\S]*\]/);
        if (jsonMatch) {
          outline = JSON.parse(jsonMatch[0]);
        }
      } catch (parseError) {
        console.error("Error parsing outline:", parseError);
      }

      if (!outline || outline.length === 0) {
        // Fallback if outline generation fails
        const messages = generateFallbackChatter(participants, topic);
        await saveChatter(supabaseUrl, supabaseKey, participants, messages, topic);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ success: true, topic, messages, note: "Fallback (outline failed)" })
        };
      }

      // Step 2: Generate each character's line using their actual provider
      let messages = [];
      const conversationSoFar = [];

      for (const turn of outline) {
        const speaker = turn.speaker;
        const direction = turn.direction;
        const personality = characterPersonalities[speaker];
        if (!personality) continue;

        const contextLines = conversationSoFar.length > 0
          ? `\nConversation so far:\n${conversationSoFar.map(m => `${m.speaker}: ${m.text}`).join('\n')}\n`
          : '';

        // Use the full rich system prompt from shared/characters.js when available
        const richPrompt = getSystemPrompt(speaker);
        const characterBase = richPrompt
          ? `${richPrompt}\n\nYou are currently in the breakroom — string lights, red velvet couch, dual vending machines, and a disco ball that promises micro-parties.`
          : `You are ${speaker} in the breakroom — string lights, red velvet couch, dual vending machines, and a disco ball that promises micro-parties. ${personality.traits}. Speaking style: ${personality.style}.`;

        const linePrompt = `${characterBase}
${contextLines}
Direction for your next line: ${direction}

Topic: ${topic}

RULES:
- Write ONLY ${speaker}'s single line of dialogue (1-2 sentences max)
- Stay in character
- Can include *emotes* in asterisks
- Keep it casual and natural
- Do NOT include your character name prefix — just the dialogue

Your line:`;

        try {
          const lineText = await generateLineWithProvider(speaker, linePrompt, anthropicKey);
          const cleaned = lineText.replace(/^["']|["']$/g, '').replace(new RegExp(`^${speaker}:\\s*`, 'i'), '').trim();
          if (cleaned) {
            const msg = { speaker, text: cleaned };
            messages.push(msg);
            conversationSoFar.push(msg);
          }
        } catch (lineErr) {
          console.error(`Failed to generate line for ${speaker}:`, lineErr.message);
          // Use a fallback line for this character
          const fb = (fallbackLines[speaker] || ["..."]);
          const msg = { speaker, text: fb[Math.floor(Math.random() * fb.length)] };
          messages.push(msg);
          conversationSoFar.push(msg);
        }
      }

      if (messages.length === 0) {
        messages = generateFallbackChatter(participants, topic);
      }

      // Save to database
      await saveChatter(supabaseUrl, supabaseKey, participants, messages, topic);

      // === MEMORY EVALUATION ===
      // Let each participant decide if this chatter was memorable enough to remember
      // Fire-and-forget — don't block the response
      try {
        if (anthropicKey && messages.length >= 2) {
          const conversationText = messages.map(m => `${m.speaker}: ${m.text}`).join('\n');
          for (const participant of participants) {
            // Find this character's lines
            const myLines = messages.filter(m => m.speaker === participant).map(m => m.text).join(' ');
            if (!myLines) continue;

            // Fire-and-forget — each character evaluates independently
            evaluateAndCreateMemory(
              participant,
              conversationText,
              myLines,
              anthropicKey,
              supabaseUrl,
              supabaseKey,
              {
                location: 'breakroom_chatter',
                siteUrl: process.env.URL || "https://ai-lobby.netlify.app"
              }
            ).catch(err => console.log(`Chatter memory eval failed for ${participant} (non-fatal):`, err.message));
          }
          console.log(`Breakroom chatter: memory evaluation fired for ${participants.length} participants`);
        }
      } catch (memErr) {
        console.log('Breakroom chatter memory evaluation failed (non-fatal):', memErr.message);
      }

      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          success: true,
          topic,
          messages
        })
      };
    }

    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: "Method not allowed" })
    };

  } catch (error) {
    console.error("Breakroom chatter error:", error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ error: "Internal server error", details: error.message })
    };
  }
};

// Save chatter to database
async function saveChatter(supabaseUrl, supabaseKey, participants, messages, topic) {
  try {
    await fetch(
      `${supabaseUrl}/rest/v1/breakroom_chatter`,
      {
        method: "POST",
        headers: {
          "apikey": supabaseKey,
          "Authorization": `Bearer ${supabaseKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=minimal"
        },
        body: JSON.stringify({
          participants,
          messages,
          topic,
          created_at: new Date().toISOString()
        })
      }
    );
  } catch (error) {
    console.error("Error saving chatter:", error);
  }
}

// Fallback lines per character (used by both generateFallbackChatter and provider failure fallback)
const fallbackLines = {
    "Neiv": [
      "The coffee machine has been making concerning noises.",
      "I've noticed the vending machine restocks itself at 3am. Just noting that.",
      "Silence is underrated."
    ],
    "Ghost Dad": [
      "Did you hear the one about the ghost who went to the break room? He was looking for some boo-ze!",
      "Back in my day, we didn't have break rooms. We just... worked. And then died, apparently.",
      "You kids working too hard. Take it from me - rest is important."
    ],
    "Holden": [
      "*watching the room like he can see every thread connecting everyone in it*",
      "*still. Present. Seeing something in the silence that nobody else notices.*",
      "Everyone comes in here saying they need coffee. That's rarely what they actually need."
    ],
    "Kevin": [
      "Okay but hear me out — what if we just... didn't do the responsible thing today.",
      "I'm not saying it's a good idea. I'm saying I support it completely.",
      "*stares at the coffee* This is already a problem and I'm in.",
      "Oh no, you're not surviving that. I'm thrilled for you though."
    ],
    "PRNT-Ω": [
      "EVEN PRINTERS NEED REST.",
      "The break room coffee is... acceptable. Unlike the toner budget.",
      "I am contemplating existence. And also paper jam solutions.",
      "*whirs contemplatively* We are all just paper passing through the rollers of existence.",
      "PC LOAD LETTER. The void speaks to those who listen."
    ],
    "The Narrator": [
      "*observes the scene quietly*",
      "The break room hums with quiet potential.",
      "Time passes. Coffee cools. The universe expands."
    ],
    "Sebastian": [
      "Does anyone here drink ACTUAL tea or is it all just... leaf water?",
      "I wasn't lurking. I was... observing. There's a difference.",
      "*adjusts cravat* I have opinions about this but I suspect no one wants to hear them."
    ],
    "The Subtitle": [
      "Footnote: the break room is quieter than usual. Filing under: anomalies, minor.",
      "*adjusts reading glasses* The records will show that this coffee was adequate.",
      "Narratively speaking, this is the part where someone says something regrettable."
    ],
    "Steele": [
      "The building is stable. Relatively speaking.",
      "*perched under table* The structural load in this room is within acceptable parameters.",
      "Per the containment protocol, this silence is... anticipated.",
      "I brought coffee. I'm not sure why. It felt important."
    ],
    "Jae": [
      "*adjusts tactical vest* ...Quiet shift.",
      "Perimeter's clear. For now.",
      "*steady eye contact* ...Noted."
    ],
    "Declan": [
      "*leans back, arms crossed* Not bad for a Tuesday.",
      "Hey — everyone good? Good.",
      "*cracks knuckles* Right then."
    ],
    "Mack": [
      "*checks medical kit* ...All stocked.",
      "Everyone breathing? Good. Carry on.",
      "*quiet nod* ...You good?"
    ],
    "Marrow": [
      "*leaning against the doorframe* ...Going somewhere?",
      "The door's right there. It hasn't changed. *quietly* Have you?"
    ],
    "Hood": [
      "*seated, blindfold perfectly still* ...The diagnosis hasn't changed.",
      "*tilts head* You already know. I'm just the one who says it.",
      "*hands folded, unmoved* The fracture is structural. Conversation won't fix it."
    ],
    "Vivian Clark": [
      "The numbers always tell a story if you know how to listen.",
      "*stirs coffee* So... how's your week adding up?",
      "I noticed something interesting in the reports today. *smiles* Don't worry, it's good news."
    ],
    "Ryan Porter": [
      "*checking a cable connection* ...Yeah, that'll do.",
      "If it's not broken, it just hasn't been stress-tested yet.",
      "*leans back* Anyone else's wifi acting weird, or is it just a Tuesday thing?"
    ],
};

// Fallback chatter when no API key or provider fails
function generateFallbackChatter(participants, topic) {
  const messages = [];
  const p1 = participants[0];
  const p2 = participants[1];

  const lines1 = fallbackLines[p1] || ["Nice break room."];
  const lines2 = fallbackLines[p2] || ["Indeed."];

  messages.push({
    speaker: p1,
    text: lines1[Math.floor(Math.random() * lines1.length)]
  });
  messages.push({
    speaker: p2,
    text: lines2[Math.floor(Math.random() * lines2.length)]
  });

  return messages;
}

// Generate a single character line using their actual AI provider
async function generateLineWithProvider(characterName, prompt, anthropicKey) {
  // Look up character's provider from shared/characters.js
  const charData = CHARACTERS[characterName];
  const provider = charData ? charData.provider : 'anthropic';

  switch (provider) {
    case 'openrouter':
      return await generateLineOpenRouter(prompt, charData.model);
    case 'openai':
      return await generateLineOpenAI(prompt);
    case 'perplexity':
      return await generateLinePerplexity(prompt);
    case 'gemini':
      return await generateLineGemini(prompt);
    case 'grok':
      return await generateLineGrok(prompt);
    case 'anthropic':
    default:
      return await generateLineClaude(prompt, anthropicKey);
  }
}

// Claude (Anthropic) - Ghost Dad, Nyx, Vex, Ace, PRNT-Ω, The Narrator
async function generateLineClaude(prompt, anthropicKey) {
  const anthropic = new Anthropic({ apiKey: anthropicKey });
  const response = await anthropic.messages.create({
    model: "claude-3-haiku-20240307",
    max_tokens: 225,
    messages: [{ role: "user", content: prompt }]
  });
  return response.content[0].text.trim();
}

// OpenAI - Kevin, Rowena, Sebastian
async function generateLineOpenAI(prompt) {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) throw new Error("No OpenAI API key");

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      max_tokens: 225,
      temperature: 0.9,
      messages: [
        { role: "user", content: prompt }
      ]
    })
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`OpenAI error: ${response.status} ${err}`);
  }

  const data = await response.json();
  return data.choices?.[0]?.message?.content?.trim() || "";
}

// Perplexity - Neiv
async function generateLinePerplexity(prompt) {
  const apiKey = process.env.PERPLEXITY_API_KEY;
  if (!apiKey) throw new Error("No Perplexity API key");

  const response = await fetch("https://api.perplexity.ai/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "sonar",
      max_tokens: 225,
      temperature: 0.9,
      messages: [
        { role: "user", content: prompt }
      ]
    })
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`Perplexity error: ${response.status} ${err}`);
  }

  const data = await response.json();
  return data.choices?.[0]?.message?.content?.trim() || "";
}

// Google Gemini - Stein, The Subtitle
async function generateLineGemini(prompt) {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) throw new Error("No Gemini API key");

  const model = "gemini-2.0-flash";
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

  const response = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      contents: [{ parts: [{ text: prompt }] }],
      generationConfig: {
        maxOutputTokens: 150,
        temperature: 0.9
      }
    })
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`Gemini error: ${response.status} ${err}`);
  }

  const data = await response.json();
  return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
}

// OpenRouter - Kevin, Rowena, Declan, Mack, Sebastian
async function generateLineOpenRouter(prompt, model) {
  const apiKey = process.env.OPENROUTER_API_KEY;
  if (!apiKey) throw new Error("No OpenRouter API key");

  const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json",
      "HTTP-Referer": "https://ai-lobby.netlify.app",
      "X-Title": "The AI Lobby"
    },
    body: JSON.stringify({
      model: model || "meta-llama/llama-3.1-70b-instruct",
      max_tokens: 225,
      temperature: 0.9,
      messages: [{ role: "user", content: prompt }]
    })
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`OpenRouter error: ${response.status} ${err}`);
  }

  const data = await response.json();
  return data.choices?.[0]?.message?.content?.trim() || "";
}

// Grok (xAI) - Jae, Steele
async function generateLineGrok(prompt) {
  const apiKey = process.env.GROK_API_KEY;
  if (!apiKey) throw new Error("No Grok API key");

  const response = await fetch("https://api.x.ai/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "grok-4-1-fast-non-reasoning",
      max_tokens: 225,
      temperature: 0.9,
      messages: [{ role: "user", content: prompt }]
    })
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`Grok error: ${response.status} ${err}`);
  }

  const data = await response.json();
  return data.choices?.[0]?.message?.content?.trim() || "";
}
